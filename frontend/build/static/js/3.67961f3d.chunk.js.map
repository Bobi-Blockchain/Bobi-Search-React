{"version":3,"file":"static/js/3.67961f3d.chunk.js","mappings":"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","sources":["../node_modules/ajv/lib/ajv.ts","../node_modules/ajv/lib/compile/codegen/code.ts","../node_modules/ajv/lib/compile/codegen/index.ts","../node_modules/ajv/lib/compile/codegen/scope.ts","../node_modules/ajv/lib/compile/errors.ts","../node_modules/ajv/lib/compile/index.ts","../node_modules/ajv/lib/compile/names.ts","../node_modules/ajv/lib/compile/ref_error.ts","../node_modules/ajv/lib/compile/resolve.ts","../node_modules/ajv/lib/compile/rules.ts","../node_modules/ajv/lib/compile/util.ts","../node_modules/ajv/lib/compile/validate/applicability.ts","../node_modules/ajv/lib/compile/validate/boolSchema.ts","../node_modules/ajv/lib/compile/validate/dataType.ts","../node_modules/ajv/lib/compile/validate/defaults.ts","../node_modules/ajv/lib/compile/validate/index.ts","../node_modules/ajv/lib/compile/validate/keyword.ts","../node_modules/ajv/lib/compile/validate/subschema.ts","../node_modules/ajv/lib/core.ts","../node_modules/ajv/lib/runtime/equal.ts","../node_modules/ajv/lib/runtime/ucs2length.ts","../node_modules/ajv/lib/runtime/uri.ts","../node_modules/ajv/lib/runtime/validation_error.ts","../node_modules/ajv/lib/vocabularies/applicator/additionalItems.ts","../node_modules/ajv/lib/vocabularies/applicator/additionalProperties.ts","../node_modules/ajv/lib/vocabularies/applicator/allOf.ts","../node_modules/ajv/lib/vocabularies/applicator/anyOf.ts","../node_modules/ajv/lib/vocabularies/applicator/contains.ts","../node_modules/ajv/lib/vocabularies/applicator/dependencies.ts","../node_modules/ajv/lib/vocabularies/applicator/if.ts","../node_modules/ajv/lib/vocabularies/applicator/index.ts","../node_modules/ajv/lib/vocabularies/applicator/items.ts","../node_modules/ajv/lib/vocabularies/applicator/items2020.ts","../node_modules/ajv/lib/vocabularies/applicator/not.ts","../node_modules/ajv/lib/vocabularies/applicator/oneOf.ts","../node_modules/ajv/lib/vocabularies/applicator/patternProperties.ts","../node_modules/ajv/lib/vocabularies/applicator/prefixItems.ts","../node_modules/ajv/lib/vocabularies/applicator/properties.ts","../node_modules/ajv/lib/vocabularies/applicator/propertyNames.ts","../node_modules/ajv/lib/vocabularies/applicator/thenElse.ts","../node_modules/ajv/lib/vocabularies/code.ts","../node_modules/ajv/lib/vocabularies/core/id.ts","../node_modules/ajv/lib/vocabularies/core/index.ts","../node_modules/ajv/lib/vocabularies/core/ref.ts","../node_modules/ajv/lib/vocabularies/discriminator/index.ts","../node_modules/ajv/lib/vocabularies/discriminator/types.ts","../node_modules/ajv/lib/vocabularies/draft7.ts","../node_modules/ajv/lib/vocabularies/format/format.ts","../node_modules/ajv/lib/vocabularies/format/index.ts","../node_modules/ajv/lib/vocabularies/metadata.ts","../node_modules/ajv/lib/vocabularies/validation/const.ts","../node_modules/ajv/lib/vocabularies/validation/enum.ts","../node_modules/ajv/lib/vocabularies/validation/index.ts","../node_modules/ajv/lib/vocabularies/validation/limitItems.ts","../node_modules/ajv/lib/vocabularies/validation/limitLength.ts","../node_modules/ajv/lib/vocabularies/validation/limitNumber.ts","../node_modules/ajv/lib/vocabularies/validation/limitProperties.ts","../node_modules/ajv/lib/vocabularies/validation/multipleOf.ts","../node_modules/ajv/lib/vocabularies/validation/pattern.ts","../node_modules/ajv/lib/vocabularies/validation/required.ts","../node_modules/ajv/lib/vocabularies/validation/uniqueItems.ts","../node_modules/fast-deep-equal/index.js","../node_modules/json-schema-traverse/index.js","../node_modules/fast-uri/index.js","../node_modules/fast-uri/lib/schemes.js","../node_modules/fast-uri/lib/scopedChars.js","../node_modules/fast-uri/lib/utils.js"],"sourcesContent":["import type {AnySchemaObject} from \"./types\"\nimport AjvCore from \"./core\"\nimport draft7Vocabularies from \"./vocabularies/draft7\"\nimport discriminator from \"./vocabularies/discriminator\"\nimport * as draft7MetaSchema from \"./refs/json-schema-draft-07.json\"\n\nconst META_SUPPORT_DATA = [\"/properties\"]\n\nconst META_SCHEMA_ID = \"http://json-schema.org/draft-07/schema\"\n\nexport class Ajv extends AjvCore {\n  _addVocabularies(): void {\n    super._addVocabularies()\n    draft7Vocabularies.forEach((v) => this.addVocabulary(v))\n    if (this.opts.discriminator) this.addKeyword(discriminator)\n  }\n\n  _addDefaultMetaSchema(): void {\n    super._addDefaultMetaSchema()\n    if (!this.opts.meta) return\n    const metaSchema = this.opts.$data\n      ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA)\n      : draft7MetaSchema\n    this.addMetaSchema(metaSchema, META_SCHEMA_ID, false)\n    this.refs[\"http://json-schema.org/schema\"] = META_SCHEMA_ID\n  }\n\n  defaultMeta(): string | AnySchemaObject | undefined {\n    return (this.opts.defaultMeta =\n      super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : undefined))\n  }\n}\n\nmodule.exports = exports = Ajv\nmodule.exports.Ajv = Ajv\nObject.defineProperty(exports, \"__esModule\", {value: true})\n\nexport default Ajv\n\nexport {\n  Format,\n  FormatDefinition,\n  AsyncFormatDefinition,\n  KeywordDefinition,\n  KeywordErrorDefinition,\n  CodeKeywordDefinition,\n  MacroKeywordDefinition,\n  FuncKeywordDefinition,\n  Vocabulary,\n  Schema,\n  SchemaObject,\n  AnySchemaObject,\n  AsyncSchema,\n  AnySchema,\n  ValidateFunction,\n  AsyncValidateFunction,\n  SchemaValidateFunction,\n  ErrorObject,\n  ErrorNoParams,\n} from \"./types\"\n\nexport {Plugin, Options, CodeOptions, InstanceOptions, Logger, ErrorsTextOptions} from \"./core\"\nexport {SchemaCxt, SchemaObjCxt} from \"./compile\"\nexport {KeywordCxt} from \"./compile/validate\"\nexport {DefinedError} from \"./vocabularies/errors\"\nexport {JSONType} from \"./compile/rules\"\nexport {JSONSchemaType} from \"./types/json-schema\"\nexport {_, str, stringify, nil, Name, Code, CodeGen, CodeGenOptions} from \"./compile/codegen\"\nexport {default as ValidationError} from \"./runtime/validation_error\"\nexport {default as MissingRefError} from \"./compile/ref_error\"\n","// eslint-disable-next-line @typescript-eslint/no-extraneous-class\nexport abstract class _CodeOrName {\n  abstract readonly str: string\n  abstract readonly names: UsedNames\n  abstract toString(): string\n  abstract emptyStr(): boolean\n}\n\nexport const IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i\n\nexport class Name extends _CodeOrName {\n  readonly str: string\n  constructor(s: string) {\n    super()\n    if (!IDENTIFIER.test(s)) throw new Error(\"CodeGen: name must be a valid identifier\")\n    this.str = s\n  }\n\n  toString(): string {\n    return this.str\n  }\n\n  emptyStr(): boolean {\n    return false\n  }\n\n  get names(): UsedNames {\n    return {[this.str]: 1}\n  }\n}\n\nexport class _Code extends _CodeOrName {\n  readonly _items: readonly CodeItem[]\n  private _str?: string\n  private _names?: UsedNames\n\n  constructor(code: string | readonly CodeItem[]) {\n    super()\n    this._items = typeof code === \"string\" ? [code] : code\n  }\n\n  toString(): string {\n    return this.str\n  }\n\n  emptyStr(): boolean {\n    if (this._items.length > 1) return false\n    const item = this._items[0]\n    return item === \"\" || item === '\"\"'\n  }\n\n  get str(): string {\n    return (this._str ??= this._items.reduce((s: string, c: CodeItem) => `${s}${c}`, \"\"))\n  }\n\n  get names(): UsedNames {\n    return (this._names ??= this._items.reduce((names: UsedNames, c) => {\n      if (c instanceof Name) names[c.str] = (names[c.str] || 0) + 1\n      return names\n    }, {}))\n  }\n}\n\nexport type CodeItem = Name | string | number | boolean | null\n\nexport type UsedNames = Record<string, number | undefined>\n\nexport type Code = _Code | Name\n\nexport type SafeExpr = Code | number | boolean | null\n\nexport const nil = new _Code(\"\")\n\ntype CodeArg = SafeExpr | string | undefined\n\nexport function _(strs: TemplateStringsArray, ...args: CodeArg[]): _Code {\n  const code: CodeItem[] = [strs[0]]\n  let i = 0\n  while (i < args.length) {\n    addCodeArg(code, args[i])\n    code.push(strs[++i])\n  }\n  return new _Code(code)\n}\n\nconst plus = new _Code(\"+\")\n\nexport function str(strs: TemplateStringsArray, ...args: (CodeArg | string[])[]): _Code {\n  const expr: CodeItem[] = [safeStringify(strs[0])]\n  let i = 0\n  while (i < args.length) {\n    expr.push(plus)\n    addCodeArg(expr, args[i])\n    expr.push(plus, safeStringify(strs[++i]))\n  }\n  optimize(expr)\n  return new _Code(expr)\n}\n\nexport function addCodeArg(code: CodeItem[], arg: CodeArg | string[]): void {\n  if (arg instanceof _Code) code.push(...arg._items)\n  else if (arg instanceof Name) code.push(arg)\n  else code.push(interpolate(arg))\n}\n\nfunction optimize(expr: CodeItem[]): void {\n  let i = 1\n  while (i < expr.length - 1) {\n    if (expr[i] === plus) {\n      const res = mergeExprItems(expr[i - 1], expr[i + 1])\n      if (res !== undefined) {\n        expr.splice(i - 1, 3, res)\n        continue\n      }\n      expr[i++] = \"+\"\n    }\n    i++\n  }\n}\n\nfunction mergeExprItems(a: CodeItem, b: CodeItem): CodeItem | undefined {\n  if (b === '\"\"') return a\n  if (a === '\"\"') return b\n  if (typeof a == \"string\") {\n    if (b instanceof Name || a[a.length - 1] !== '\"') return\n    if (typeof b != \"string\") return `${a.slice(0, -1)}${b}\"`\n    if (b[0] === '\"') return a.slice(0, -1) + b.slice(1)\n    return\n  }\n  if (typeof b == \"string\" && b[0] === '\"' && !(a instanceof Name)) return `\"${a}${b.slice(1)}`\n  return\n}\n\nexport function strConcat(c1: Code, c2: Code): Code {\n  return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`\n}\n\n// TODO do not allow arrays here\nfunction interpolate(x?: string | string[] | number | boolean | null): SafeExpr | string {\n  return typeof x == \"number\" || typeof x == \"boolean\" || x === null\n    ? x\n    : safeStringify(Array.isArray(x) ? x.join(\",\") : x)\n}\n\nexport function stringify(x: unknown): Code {\n  return new _Code(safeStringify(x))\n}\n\nexport function safeStringify(x: unknown): string {\n  return JSON.stringify(x)\n    .replace(/\\u2028/g, \"\\\\u2028\")\n    .replace(/\\u2029/g, \"\\\\u2029\")\n}\n\nexport function getProperty(key: Code | string | number): Code {\n  return typeof key == \"string\" && IDENTIFIER.test(key) ? new _Code(`.${key}`) : _`[${key}]`\n}\n\n//Does best effort to format the name properly\nexport function getEsmExportName(key: Code | string | number): Code {\n  if (typeof key == \"string\" && IDENTIFIER.test(key)) {\n    return new _Code(`${key}`)\n  }\n  throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`)\n}\n\nexport function regexpCode(rx: RegExp): Code {\n  return new _Code(rx.toString())\n}\n","import type {ScopeValueSets, NameValue, ValueScope, ValueScopeName} from \"./scope\"\nimport {_, nil, _Code, Code, Name, UsedNames, CodeItem, addCodeArg, _CodeOrName} from \"./code\"\nimport {Scope, varKinds} from \"./scope\"\n\nexport {_, str, strConcat, nil, getProperty, stringify, regexpCode, Name, Code} from \"./code\"\nexport {Scope, ScopeStore, ValueScope, ValueScopeName, ScopeValueSets, varKinds} from \"./scope\"\n\n// type for expressions that can be safely inserted in code without quotes\nexport type SafeExpr = Code | number | boolean | null\n\n// type that is either Code of function that adds code to CodeGen instance using its methods\nexport type Block = Code | (() => void)\n\nexport const operators = {\n  GT: new _Code(\">\"),\n  GTE: new _Code(\">=\"),\n  LT: new _Code(\"<\"),\n  LTE: new _Code(\"<=\"),\n  EQ: new _Code(\"===\"),\n  NEQ: new _Code(\"!==\"),\n  NOT: new _Code(\"!\"),\n  OR: new _Code(\"||\"),\n  AND: new _Code(\"&&\"),\n  ADD: new _Code(\"+\"),\n}\n\nabstract class Node {\n  abstract readonly names: UsedNames\n\n  optimizeNodes(): this | ChildNode | ChildNode[] | undefined {\n    return this\n  }\n\n  optimizeNames(_names: UsedNames, _constants: Constants): this | undefined {\n    return this\n  }\n\n  // get count(): number {\n  //   return 1\n  // }\n}\n\nclass Def extends Node {\n  constructor(\n    private readonly varKind: Name,\n    private readonly name: Name,\n    private rhs?: SafeExpr\n  ) {\n    super()\n  }\n\n  render({es5, _n}: CGOptions): string {\n    const varKind = es5 ? varKinds.var : this.varKind\n    const rhs = this.rhs === undefined ? \"\" : ` = ${this.rhs}`\n    return `${varKind} ${this.name}${rhs};` + _n\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    if (!names[this.name.str]) return\n    if (this.rhs) this.rhs = optimizeExpr(this.rhs, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    return this.rhs instanceof _CodeOrName ? this.rhs.names : {}\n  }\n}\n\nclass Assign extends Node {\n  constructor(\n    readonly lhs: Code,\n    public rhs: SafeExpr,\n    private readonly sideEffects?: boolean\n  ) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    return `${this.lhs} = ${this.rhs};` + _n\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    if (this.lhs instanceof Name && !names[this.lhs.str] && !this.sideEffects) return\n    this.rhs = optimizeExpr(this.rhs, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    const names = this.lhs instanceof Name ? {} : {...this.lhs.names}\n    return addExprNames(names, this.rhs)\n  }\n}\n\nclass AssignOp extends Assign {\n  constructor(\n    lhs: Code,\n    private readonly op: Code,\n    rhs: SafeExpr,\n    sideEffects?: boolean\n  ) {\n    super(lhs, rhs, sideEffects)\n  }\n\n  render({_n}: CGOptions): string {\n    return `${this.lhs} ${this.op}= ${this.rhs};` + _n\n  }\n}\n\nclass Label extends Node {\n  readonly names: UsedNames = {}\n  constructor(readonly label: Name) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    return `${this.label}:` + _n\n  }\n}\n\nclass Break extends Node {\n  readonly names: UsedNames = {}\n  constructor(readonly label?: Code) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    const label = this.label ? ` ${this.label}` : \"\"\n    return `break${label};` + _n\n  }\n}\n\nclass Throw extends Node {\n  constructor(readonly error: Code) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    return `throw ${this.error};` + _n\n  }\n\n  get names(): UsedNames {\n    return this.error.names\n  }\n}\n\nclass AnyCode extends Node {\n  constructor(private code: SafeExpr) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    return `${this.code};` + _n\n  }\n\n  optimizeNodes(): this | undefined {\n    return `${this.code}` ? this : undefined\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this {\n    this.code = optimizeExpr(this.code, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    return this.code instanceof _CodeOrName ? this.code.names : {}\n  }\n}\n\nabstract class ParentNode extends Node {\n  constructor(readonly nodes: ChildNode[] = []) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    return this.nodes.reduce((code, n) => code + n.render(opts), \"\")\n  }\n\n  optimizeNodes(): this | ChildNode | ChildNode[] | undefined {\n    const {nodes} = this\n    let i = nodes.length\n    while (i--) {\n      const n = nodes[i].optimizeNodes()\n      if (Array.isArray(n)) nodes.splice(i, 1, ...n)\n      else if (n) nodes[i] = n\n      else nodes.splice(i, 1)\n    }\n    return nodes.length > 0 ? this : undefined\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    const {nodes} = this\n    let i = nodes.length\n    while (i--) {\n      // iterating backwards improves 1-pass optimization\n      const n = nodes[i]\n      if (n.optimizeNames(names, constants)) continue\n      subtractNames(names, n.names)\n      nodes.splice(i, 1)\n    }\n    return nodes.length > 0 ? this : undefined\n  }\n\n  get names(): UsedNames {\n    return this.nodes.reduce((names: UsedNames, n) => addNames(names, n.names), {})\n  }\n\n  // get count(): number {\n  //   return this.nodes.reduce((c, n) => c + n.count, 1)\n  // }\n}\n\nabstract class BlockNode extends ParentNode {\n  render(opts: CGOptions): string {\n    return \"{\" + opts._n + super.render(opts) + \"}\" + opts._n\n  }\n}\n\nclass Root extends ParentNode {}\n\nclass Else extends BlockNode {\n  static readonly kind = \"else\"\n}\n\nclass If extends BlockNode {\n  static readonly kind = \"if\"\n  else?: If | Else\n  constructor(\n    private condition: Code | boolean,\n    nodes?: ChildNode[]\n  ) {\n    super(nodes)\n  }\n\n  render(opts: CGOptions): string {\n    let code = `if(${this.condition})` + super.render(opts)\n    if (this.else) code += \"else \" + this.else.render(opts)\n    return code\n  }\n\n  optimizeNodes(): If | ChildNode[] | undefined {\n    super.optimizeNodes()\n    const cond = this.condition\n    if (cond === true) return this.nodes // else is ignored here\n    let e = this.else\n    if (e) {\n      const ns = e.optimizeNodes()\n      e = this.else = Array.isArray(ns) ? new Else(ns) : (ns as Else | undefined)\n    }\n    if (e) {\n      if (cond === false) return e instanceof If ? e : e.nodes\n      if (this.nodes.length) return this\n      return new If(not(cond), e instanceof If ? [e] : e.nodes)\n    }\n    if (cond === false || !this.nodes.length) return undefined\n    return this\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    this.else = this.else?.optimizeNames(names, constants)\n    if (!(super.optimizeNames(names, constants) || this.else)) return\n    this.condition = optimizeExpr(this.condition, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    const names = super.names\n    addExprNames(names, this.condition)\n    if (this.else) addNames(names, this.else.names)\n    return names\n  }\n\n  // get count(): number {\n  //   return super.count + (this.else?.count || 0)\n  // }\n}\n\nabstract class For extends BlockNode {\n  static readonly kind = \"for\"\n}\n\nclass ForLoop extends For {\n  constructor(private iteration: Code) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    return `for(${this.iteration})` + super.render(opts)\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    if (!super.optimizeNames(names, constants)) return\n    this.iteration = optimizeExpr(this.iteration, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    return addNames(super.names, this.iteration.names)\n  }\n}\n\nclass ForRange extends For {\n  constructor(\n    private readonly varKind: Name,\n    private readonly name: Name,\n    private readonly from: SafeExpr,\n    private readonly to: SafeExpr\n  ) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    const varKind = opts.es5 ? varKinds.var : this.varKind\n    const {name, from, to} = this\n    return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts)\n  }\n\n  get names(): UsedNames {\n    const names = addExprNames(super.names, this.from)\n    return addExprNames(names, this.to)\n  }\n}\n\nclass ForIter extends For {\n  constructor(\n    private readonly loop: \"of\" | \"in\",\n    private readonly varKind: Name,\n    private readonly name: Name,\n    private iterable: Code\n  ) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts)\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    if (!super.optimizeNames(names, constants)) return\n    this.iterable = optimizeExpr(this.iterable, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    return addNames(super.names, this.iterable.names)\n  }\n}\n\nclass Func extends BlockNode {\n  static readonly kind = \"func\"\n  constructor(\n    public name: Name,\n    public args: Code,\n    public async?: boolean\n  ) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    const _async = this.async ? \"async \" : \"\"\n    return `${_async}function ${this.name}(${this.args})` + super.render(opts)\n  }\n}\n\nclass Return extends ParentNode {\n  static readonly kind = \"return\"\n\n  render(opts: CGOptions): string {\n    return \"return \" + super.render(opts)\n  }\n}\n\nclass Try extends BlockNode {\n  catch?: Catch\n  finally?: Finally\n\n  render(opts: CGOptions): string {\n    let code = \"try\" + super.render(opts)\n    if (this.catch) code += this.catch.render(opts)\n    if (this.finally) code += this.finally.render(opts)\n    return code\n  }\n\n  optimizeNodes(): this {\n    super.optimizeNodes()\n    this.catch?.optimizeNodes() as Catch | undefined\n    this.finally?.optimizeNodes() as Finally | undefined\n    return this\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this {\n    super.optimizeNames(names, constants)\n    this.catch?.optimizeNames(names, constants)\n    this.finally?.optimizeNames(names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    const names = super.names\n    if (this.catch) addNames(names, this.catch.names)\n    if (this.finally) addNames(names, this.finally.names)\n    return names\n  }\n\n  // get count(): number {\n  //   return super.count + (this.catch?.count || 0) + (this.finally?.count || 0)\n  // }\n}\n\nclass Catch extends BlockNode {\n  static readonly kind = \"catch\"\n  constructor(readonly error: Name) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    return `catch(${this.error})` + super.render(opts)\n  }\n}\n\nclass Finally extends BlockNode {\n  static readonly kind = \"finally\"\n  render(opts: CGOptions): string {\n    return \"finally\" + super.render(opts)\n  }\n}\n\ntype StartBlockNode = If | For | Func | Return | Try\n\ntype LeafNode = Def | Assign | Label | Break | Throw | AnyCode\n\ntype ChildNode = StartBlockNode | LeafNode\n\ntype EndBlockNodeType =\n  | typeof If\n  | typeof Else\n  | typeof For\n  | typeof Func\n  | typeof Return\n  | typeof Catch\n  | typeof Finally\n\ntype Constants = Record<string, SafeExpr | undefined>\n\nexport interface CodeGenOptions {\n  es5?: boolean\n  lines?: boolean\n  ownProperties?: boolean\n}\n\ninterface CGOptions extends CodeGenOptions {\n  _n: \"\\n\" | \"\"\n}\n\nexport class CodeGen {\n  readonly _scope: Scope\n  readonly _extScope: ValueScope\n  readonly _values: ScopeValueSets = {}\n  private readonly _nodes: ParentNode[]\n  private readonly _blockStarts: number[] = []\n  private readonly _constants: Constants = {}\n  private readonly opts: CGOptions\n\n  constructor(extScope: ValueScope, opts: CodeGenOptions = {}) {\n    this.opts = {...opts, _n: opts.lines ? \"\\n\" : \"\"}\n    this._extScope = extScope\n    this._scope = new Scope({parent: extScope})\n    this._nodes = [new Root()]\n  }\n\n  toString(): string {\n    return this._root.render(this.opts)\n  }\n\n  // returns unique name in the internal scope\n  name(prefix: string): Name {\n    return this._scope.name(prefix)\n  }\n\n  // reserves unique name in the external scope\n  scopeName(prefix: string): ValueScopeName {\n    return this._extScope.name(prefix)\n  }\n\n  // reserves unique name in the external scope and assigns value to it\n  scopeValue(prefixOrName: ValueScopeName | string, value: NameValue): Name {\n    const name = this._extScope.value(prefixOrName, value)\n    const vs = this._values[name.prefix] || (this._values[name.prefix] = new Set())\n    vs.add(name)\n    return name\n  }\n\n  getScopeValue(prefix: string, keyOrRef: unknown): ValueScopeName | undefined {\n    return this._extScope.getValue(prefix, keyOrRef)\n  }\n\n  // return code that assigns values in the external scope to the names that are used internally\n  // (same names that were returned by gen.scopeName or gen.scopeValue)\n  scopeRefs(scopeName: Name): Code {\n    return this._extScope.scopeRefs(scopeName, this._values)\n  }\n\n  scopeCode(): Code {\n    return this._extScope.scopeCode(this._values)\n  }\n\n  private _def(\n    varKind: Name,\n    nameOrPrefix: Name | string,\n    rhs?: SafeExpr,\n    constant?: boolean\n  ): Name {\n    const name = this._scope.toName(nameOrPrefix)\n    if (rhs !== undefined && constant) this._constants[name.str] = rhs\n    this._leafNode(new Def(varKind, name, rhs))\n    return name\n  }\n\n  // `const` declaration (`var` in es5 mode)\n  const(nameOrPrefix: Name | string, rhs: SafeExpr, _constant?: boolean): Name {\n    return this._def(varKinds.const, nameOrPrefix, rhs, _constant)\n  }\n\n  // `let` declaration with optional assignment (`var` in es5 mode)\n  let(nameOrPrefix: Name | string, rhs?: SafeExpr, _constant?: boolean): Name {\n    return this._def(varKinds.let, nameOrPrefix, rhs, _constant)\n  }\n\n  // `var` declaration with optional assignment\n  var(nameOrPrefix: Name | string, rhs?: SafeExpr, _constant?: boolean): Name {\n    return this._def(varKinds.var, nameOrPrefix, rhs, _constant)\n  }\n\n  // assignment code\n  assign(lhs: Code, rhs: SafeExpr, sideEffects?: boolean): CodeGen {\n    return this._leafNode(new Assign(lhs, rhs, sideEffects))\n  }\n\n  // `+=` code\n  add(lhs: Code, rhs: SafeExpr): CodeGen {\n    return this._leafNode(new AssignOp(lhs, operators.ADD, rhs))\n  }\n\n  // appends passed SafeExpr to code or executes Block\n  code(c: Block | SafeExpr): CodeGen {\n    if (typeof c == \"function\") c()\n    else if (c !== nil) this._leafNode(new AnyCode(c))\n    return this\n  }\n\n  // returns code for object literal for the passed argument list of key-value pairs\n  object(...keyValues: [Name | string, SafeExpr | string][]): _Code {\n    const code: CodeItem[] = [\"{\"]\n    for (const [key, value] of keyValues) {\n      if (code.length > 1) code.push(\",\")\n      code.push(key)\n      if (key !== value || this.opts.es5) {\n        code.push(\":\")\n        addCodeArg(code, value)\n      }\n    }\n    code.push(\"}\")\n    return new _Code(code)\n  }\n\n  // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)\n  if(condition: Code | boolean, thenBody?: Block, elseBody?: Block): CodeGen {\n    this._blockNode(new If(condition))\n\n    if (thenBody && elseBody) {\n      this.code(thenBody).else().code(elseBody).endIf()\n    } else if (thenBody) {\n      this.code(thenBody).endIf()\n    } else if (elseBody) {\n      throw new Error('CodeGen: \"else\" body without \"then\" body')\n    }\n    return this\n  }\n\n  // `else if` clause - invalid without `if` or after `else` clauses\n  elseIf(condition: Code | boolean): CodeGen {\n    return this._elseNode(new If(condition))\n  }\n\n  // `else` clause - only valid after `if` or `else if` clauses\n  else(): CodeGen {\n    return this._elseNode(new Else())\n  }\n\n  // end `if` statement (needed if gen.if was used only with condition)\n  endIf(): CodeGen {\n    return this._endBlockNode(If, Else)\n  }\n\n  private _for(node: For, forBody?: Block): CodeGen {\n    this._blockNode(node)\n    if (forBody) this.code(forBody).endFor()\n    return this\n  }\n\n  // a generic `for` clause (or statement if `forBody` is passed)\n  for(iteration: Code, forBody?: Block): CodeGen {\n    return this._for(new ForLoop(iteration), forBody)\n  }\n\n  // `for` statement for a range of values\n  forRange(\n    nameOrPrefix: Name | string,\n    from: SafeExpr,\n    to: SafeExpr,\n    forBody: (index: Name) => void,\n    varKind: Code = this.opts.es5 ? varKinds.var : varKinds.let\n  ): CodeGen {\n    const name = this._scope.toName(nameOrPrefix)\n    return this._for(new ForRange(varKind, name, from, to), () => forBody(name))\n  }\n\n  // `for-of` statement (in es5 mode replace with a normal for loop)\n  forOf(\n    nameOrPrefix: Name | string,\n    iterable: Code,\n    forBody: (item: Name) => void,\n    varKind: Code = varKinds.const\n  ): CodeGen {\n    const name = this._scope.toName(nameOrPrefix)\n    if (this.opts.es5) {\n      const arr = iterable instanceof Name ? iterable : this.var(\"_arr\", iterable)\n      return this.forRange(\"_i\", 0, _`${arr}.length`, (i) => {\n        this.var(name, _`${arr}[${i}]`)\n        forBody(name)\n      })\n    }\n    return this._for(new ForIter(\"of\", varKind, name, iterable), () => forBody(name))\n  }\n\n  // `for-in` statement.\n  // With option `ownProperties` replaced with a `for-of` loop for object keys\n  forIn(\n    nameOrPrefix: Name | string,\n    obj: Code,\n    forBody: (item: Name) => void,\n    varKind: Code = this.opts.es5 ? varKinds.var : varKinds.const\n  ): CodeGen {\n    if (this.opts.ownProperties) {\n      return this.forOf(nameOrPrefix, _`Object.keys(${obj})`, forBody)\n    }\n    const name = this._scope.toName(nameOrPrefix)\n    return this._for(new ForIter(\"in\", varKind, name, obj), () => forBody(name))\n  }\n\n  // end `for` loop\n  endFor(): CodeGen {\n    return this._endBlockNode(For)\n  }\n\n  // `label` statement\n  label(label: Name): CodeGen {\n    return this._leafNode(new Label(label))\n  }\n\n  // `break` statement\n  break(label?: Code): CodeGen {\n    return this._leafNode(new Break(label))\n  }\n\n  // `return` statement\n  return(value: Block | SafeExpr): CodeGen {\n    const node = new Return()\n    this._blockNode(node)\n    this.code(value)\n    if (node.nodes.length !== 1) throw new Error('CodeGen: \"return\" should have one node')\n    return this._endBlockNode(Return)\n  }\n\n  // `try` statement\n  try(tryBody: Block, catchCode?: (e: Name) => void, finallyCode?: Block): CodeGen {\n    if (!catchCode && !finallyCode) throw new Error('CodeGen: \"try\" without \"catch\" and \"finally\"')\n    const node = new Try()\n    this._blockNode(node)\n    this.code(tryBody)\n    if (catchCode) {\n      const error = this.name(\"e\")\n      this._currNode = node.catch = new Catch(error)\n      catchCode(error)\n    }\n    if (finallyCode) {\n      this._currNode = node.finally = new Finally()\n      this.code(finallyCode)\n    }\n    return this._endBlockNode(Catch, Finally)\n  }\n\n  // `throw` statement\n  throw(error: Code): CodeGen {\n    return this._leafNode(new Throw(error))\n  }\n\n  // start self-balancing block\n  block(body?: Block, nodeCount?: number): CodeGen {\n    this._blockStarts.push(this._nodes.length)\n    if (body) this.code(body).endBlock(nodeCount)\n    return this\n  }\n\n  // end the current self-balancing block\n  endBlock(nodeCount?: number): CodeGen {\n    const len = this._blockStarts.pop()\n    if (len === undefined) throw new Error(\"CodeGen: not in self-balancing block\")\n    const toClose = this._nodes.length - len\n    if (toClose < 0 || (nodeCount !== undefined && toClose !== nodeCount)) {\n      throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`)\n    }\n    this._nodes.length = len\n    return this\n  }\n\n  // `function` heading (or definition if funcBody is passed)\n  func(name: Name, args: Code = nil, async?: boolean, funcBody?: Block): CodeGen {\n    this._blockNode(new Func(name, args, async))\n    if (funcBody) this.code(funcBody).endFunc()\n    return this\n  }\n\n  // end function definition\n  endFunc(): CodeGen {\n    return this._endBlockNode(Func)\n  }\n\n  optimize(n = 1): void {\n    while (n-- > 0) {\n      this._root.optimizeNodes()\n      this._root.optimizeNames(this._root.names, this._constants)\n    }\n  }\n\n  private _leafNode(node: LeafNode): CodeGen {\n    this._currNode.nodes.push(node)\n    return this\n  }\n\n  private _blockNode(node: StartBlockNode): void {\n    this._currNode.nodes.push(node)\n    this._nodes.push(node)\n  }\n\n  private _endBlockNode(N1: EndBlockNodeType, N2?: EndBlockNodeType): CodeGen {\n    const n = this._currNode\n    if (n instanceof N1 || (N2 && n instanceof N2)) {\n      this._nodes.pop()\n      return this\n    }\n    throw new Error(`CodeGen: not in block \"${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}\"`)\n  }\n\n  private _elseNode(node: If | Else): CodeGen {\n    const n = this._currNode\n    if (!(n instanceof If)) {\n      throw new Error('CodeGen: \"else\" without \"if\"')\n    }\n    this._currNode = n.else = node\n    return this\n  }\n\n  private get _root(): Root {\n    return this._nodes[0] as Root\n  }\n\n  private get _currNode(): ParentNode {\n    const ns = this._nodes\n    return ns[ns.length - 1]\n  }\n\n  private set _currNode(node: ParentNode) {\n    const ns = this._nodes\n    ns[ns.length - 1] = node\n  }\n\n  // get nodeCount(): number {\n  //   return this._root.count\n  // }\n}\n\nfunction addNames(names: UsedNames, from: UsedNames): UsedNames {\n  for (const n in from) names[n] = (names[n] || 0) + (from[n] || 0)\n  return names\n}\n\nfunction addExprNames(names: UsedNames, from: SafeExpr): UsedNames {\n  return from instanceof _CodeOrName ? addNames(names, from.names) : names\n}\n\nfunction optimizeExpr<T extends SafeExpr | Code>(expr: T, names: UsedNames, constants: Constants): T\nfunction optimizeExpr(expr: SafeExpr, names: UsedNames, constants: Constants): SafeExpr {\n  if (expr instanceof Name) return replaceName(expr)\n  if (!canOptimize(expr)) return expr\n  return new _Code(\n    expr._items.reduce((items: CodeItem[], c: SafeExpr | string) => {\n      if (c instanceof Name) c = replaceName(c)\n      if (c instanceof _Code) items.push(...c._items)\n      else items.push(c)\n      return items\n    }, [])\n  )\n\n  function replaceName(n: Name): SafeExpr {\n    const c = constants[n.str]\n    if (c === undefined || names[n.str] !== 1) return n\n    delete names[n.str]\n    return c\n  }\n\n  function canOptimize(e: SafeExpr): e is _Code {\n    return (\n      e instanceof _Code &&\n      e._items.some(\n        (c) => c instanceof Name && names[c.str] === 1 && constants[c.str] !== undefined\n      )\n    )\n  }\n}\n\nfunction subtractNames(names: UsedNames, from: UsedNames): void {\n  for (const n in from) names[n] = (names[n] || 0) - (from[n] || 0)\n}\n\nexport function not<T extends Code | SafeExpr>(x: T): T\nexport function not(x: Code | SafeExpr): Code | SafeExpr {\n  return typeof x == \"boolean\" || typeof x == \"number\" || x === null ? !x : _`!${par(x)}`\n}\n\nconst andCode = mappend(operators.AND)\n\n// boolean AND (&&) expression with the passed arguments\nexport function and(...args: Code[]): Code {\n  return args.reduce(andCode)\n}\n\nconst orCode = mappend(operators.OR)\n\n// boolean OR (||) expression with the passed arguments\nexport function or(...args: Code[]): Code {\n  return args.reduce(orCode)\n}\n\ntype MAppend = (x: Code, y: Code) => Code\n\nfunction mappend(op: Code): MAppend {\n  return (x, y) => (x === nil ? y : y === nil ? x : _`${par(x)} ${op} ${par(y)}`)\n}\n\nfunction par(x: Code): Code {\n  return x instanceof Name ? x : _`(${x})`\n}\n","import {_, nil, Code, Name} from \"./code\"\n\ninterface NameGroup {\n  prefix: string\n  index: number\n}\n\nexport interface NameValue {\n  ref: ValueReference // this is the reference to any value that can be referred to from generated code via `globals` var in the closure\n  key?: unknown // any key to identify a global to avoid duplicates, if not passed ref is used\n  code?: Code // this is the code creating the value needed for standalone code wit_out closure - can be a primitive value, function or import (`require`)\n}\n\nexport type ValueReference = unknown // possibly make CodeGen parameterized type on this type\n\nclass ValueError extends Error {\n  readonly value?: NameValue\n  constructor(name: ValueScopeName) {\n    super(`CodeGen: \"code\" for ${name} not defined`)\n    this.value = name.value\n  }\n}\n\ninterface ScopeOptions {\n  prefixes?: Set<string>\n  parent?: Scope\n}\n\ninterface ValueScopeOptions extends ScopeOptions {\n  scope: ScopeStore\n  es5?: boolean\n  lines?: boolean\n}\n\nexport type ScopeStore = Record<string, ValueReference[] | undefined>\n\ntype ScopeValues = {\n  [Prefix in string]?: Map<unknown, ValueScopeName>\n}\n\nexport type ScopeValueSets = {\n  [Prefix in string]?: Set<ValueScopeName>\n}\n\nexport enum UsedValueState {\n  Started,\n  Completed,\n}\n\nexport type UsedScopeValues = {\n  [Prefix in string]?: Map<ValueScopeName, UsedValueState | undefined>\n}\n\nexport const varKinds = {\n  const: new Name(\"const\"),\n  let: new Name(\"let\"),\n  var: new Name(\"var\"),\n}\n\nexport class Scope {\n  protected readonly _names: {[Prefix in string]?: NameGroup} = {}\n  protected readonly _prefixes?: Set<string>\n  protected readonly _parent?: Scope\n\n  constructor({prefixes, parent}: ScopeOptions = {}) {\n    this._prefixes = prefixes\n    this._parent = parent\n  }\n\n  toName(nameOrPrefix: Name | string): Name {\n    return nameOrPrefix instanceof Name ? nameOrPrefix : this.name(nameOrPrefix)\n  }\n\n  name(prefix: string): Name {\n    return new Name(this._newName(prefix))\n  }\n\n  protected _newName(prefix: string): string {\n    const ng = this._names[prefix] || this._nameGroup(prefix)\n    return `${prefix}${ng.index++}`\n  }\n\n  private _nameGroup(prefix: string): NameGroup {\n    if (this._parent?._prefixes?.has(prefix) || (this._prefixes && !this._prefixes.has(prefix))) {\n      throw new Error(`CodeGen: prefix \"${prefix}\" is not allowed in this scope`)\n    }\n    return (this._names[prefix] = {prefix, index: 0})\n  }\n}\n\ninterface ScopePath {\n  property: string\n  itemIndex: number\n}\n\nexport class ValueScopeName extends Name {\n  readonly prefix: string\n  value?: NameValue\n  scopePath?: Code\n\n  constructor(prefix: string, nameStr: string) {\n    super(nameStr)\n    this.prefix = prefix\n  }\n\n  setValue(value: NameValue, {property, itemIndex}: ScopePath): void {\n    this.value = value\n    this.scopePath = _`.${new Name(property)}[${itemIndex}]`\n  }\n}\n\ninterface VSOptions extends ValueScopeOptions {\n  _n: Code\n}\n\nconst line = _`\\n`\n\nexport class ValueScope extends Scope {\n  protected readonly _values: ScopeValues = {}\n  protected readonly _scope: ScopeStore\n  readonly opts: VSOptions\n\n  constructor(opts: ValueScopeOptions) {\n    super(opts)\n    this._scope = opts.scope\n    this.opts = {...opts, _n: opts.lines ? line : nil}\n  }\n\n  get(): ScopeStore {\n    return this._scope\n  }\n\n  name(prefix: string): ValueScopeName {\n    return new ValueScopeName(prefix, this._newName(prefix))\n  }\n\n  value(nameOrPrefix: ValueScopeName | string, value: NameValue): ValueScopeName {\n    if (value.ref === undefined) throw new Error(\"CodeGen: ref must be passed in value\")\n    const name = this.toName(nameOrPrefix) as ValueScopeName\n    const {prefix} = name\n    const valueKey = value.key ?? value.ref\n    let vs = this._values[prefix]\n    if (vs) {\n      const _name = vs.get(valueKey)\n      if (_name) return _name\n    } else {\n      vs = this._values[prefix] = new Map()\n    }\n    vs.set(valueKey, name)\n\n    const s = this._scope[prefix] || (this._scope[prefix] = [])\n    const itemIndex = s.length\n    s[itemIndex] = value.ref\n    name.setValue(value, {property: prefix, itemIndex})\n    return name\n  }\n\n  getValue(prefix: string, keyOrRef: unknown): ValueScopeName | undefined {\n    const vs = this._values[prefix]\n    if (!vs) return\n    return vs.get(keyOrRef)\n  }\n\n  scopeRefs(scopeName: Name, values: ScopeValues | ScopeValueSets = this._values): Code {\n    return this._reduceValues(values, (name: ValueScopeName) => {\n      if (name.scopePath === undefined) throw new Error(`CodeGen: name \"${name}\" has no value`)\n      return _`${scopeName}${name.scopePath}`\n    })\n  }\n\n  scopeCode(\n    values: ScopeValues | ScopeValueSets = this._values,\n    usedValues?: UsedScopeValues,\n    getCode?: (n: ValueScopeName) => Code | undefined\n  ): Code {\n    return this._reduceValues(\n      values,\n      (name: ValueScopeName) => {\n        if (name.value === undefined) throw new Error(`CodeGen: name \"${name}\" has no value`)\n        return name.value.code\n      },\n      usedValues,\n      getCode\n    )\n  }\n\n  private _reduceValues(\n    values: ScopeValues | ScopeValueSets,\n    valueCode: (n: ValueScopeName) => Code | undefined,\n    usedValues: UsedScopeValues = {},\n    getCode?: (n: ValueScopeName) => Code | undefined\n  ): Code {\n    let code: Code = nil\n    for (const prefix in values) {\n      const vs = values[prefix]\n      if (!vs) continue\n      const nameSet = (usedValues[prefix] = usedValues[prefix] || new Map())\n      vs.forEach((name: ValueScopeName) => {\n        if (nameSet.has(name)) return\n        nameSet.set(name, UsedValueState.Started)\n        let c = valueCode(name)\n        if (c) {\n          const def = this.opts.es5 ? varKinds.var : varKinds.const\n          code = _`${code}${def} ${name} = ${c};${this.opts._n}`\n        } else if ((c = getCode?.(name))) {\n          code = _`${code}${c}${this.opts._n}`\n        } else {\n          throw new ValueError(name)\n        }\n        nameSet.set(name, UsedValueState.Completed)\n      })\n    }\n    return code\n  }\n}\n","import type {KeywordErrorCxt, KeywordErrorDefinition} from \"../types\"\nimport type {SchemaCxt} from \"./index\"\nimport {CodeGen, _, str, strConcat, Code, Name} from \"./codegen\"\nimport {SafeExpr} from \"./codegen/code\"\nimport {getErrorPath, Type} from \"./util\"\nimport N from \"./names\"\n\nexport const keywordError: KeywordErrorDefinition = {\n  message: ({keyword}) => str`must pass \"${keyword}\" keyword validation`,\n}\n\nexport const keyword$DataError: KeywordErrorDefinition = {\n  message: ({keyword, schemaType}) =>\n    schemaType\n      ? str`\"${keyword}\" keyword must be ${schemaType} ($data)`\n      : str`\"${keyword}\" keyword is invalid ($data)`,\n}\n\nexport interface ErrorPaths {\n  instancePath?: Code\n  schemaPath?: string\n  parentSchema?: boolean\n}\n\nexport function reportError(\n  cxt: KeywordErrorCxt,\n  error: KeywordErrorDefinition = keywordError,\n  errorPaths?: ErrorPaths,\n  overrideAllErrors?: boolean\n): void {\n  const {it} = cxt\n  const {gen, compositeRule, allErrors} = it\n  const errObj = errorObjectCode(cxt, error, errorPaths)\n  if (overrideAllErrors ?? (compositeRule || allErrors)) {\n    addError(gen, errObj)\n  } else {\n    returnErrors(it, _`[${errObj}]`)\n  }\n}\n\nexport function reportExtraError(\n  cxt: KeywordErrorCxt,\n  error: KeywordErrorDefinition = keywordError,\n  errorPaths?: ErrorPaths\n): void {\n  const {it} = cxt\n  const {gen, compositeRule, allErrors} = it\n  const errObj = errorObjectCode(cxt, error, errorPaths)\n  addError(gen, errObj)\n  if (!(compositeRule || allErrors)) {\n    returnErrors(it, N.vErrors)\n  }\n}\n\nexport function resetErrorsCount(gen: CodeGen, errsCount: Name): void {\n  gen.assign(N.errors, errsCount)\n  gen.if(_`${N.vErrors} !== null`, () =>\n    gen.if(\n      errsCount,\n      () => gen.assign(_`${N.vErrors}.length`, errsCount),\n      () => gen.assign(N.vErrors, null)\n    )\n  )\n}\n\nexport function extendErrors({\n  gen,\n  keyword,\n  schemaValue,\n  data,\n  errsCount,\n  it,\n}: KeywordErrorCxt): void {\n  /* istanbul ignore if */\n  if (errsCount === undefined) throw new Error(\"ajv implementation error\")\n  const err = gen.name(\"err\")\n  gen.forRange(\"i\", errsCount, N.errors, (i) => {\n    gen.const(err, _`${N.vErrors}[${i}]`)\n    gen.if(_`${err}.instancePath === undefined`, () =>\n      gen.assign(_`${err}.instancePath`, strConcat(N.instancePath, it.errorPath))\n    )\n    gen.assign(_`${err}.schemaPath`, str`${it.errSchemaPath}/${keyword}`)\n    if (it.opts.verbose) {\n      gen.assign(_`${err}.schema`, schemaValue)\n      gen.assign(_`${err}.data`, data)\n    }\n  })\n}\n\nfunction addError(gen: CodeGen, errObj: Code): void {\n  const err = gen.const(\"err\", errObj)\n  gen.if(\n    _`${N.vErrors} === null`,\n    () => gen.assign(N.vErrors, _`[${err}]`),\n    _`${N.vErrors}.push(${err})`\n  )\n  gen.code(_`${N.errors}++`)\n}\n\nfunction returnErrors(it: SchemaCxt, errs: Code): void {\n  const {gen, validateName, schemaEnv} = it\n  if (schemaEnv.$async) {\n    gen.throw(_`new ${it.ValidationError as Name}(${errs})`)\n  } else {\n    gen.assign(_`${validateName}.errors`, errs)\n    gen.return(false)\n  }\n}\n\nconst E = {\n  keyword: new Name(\"keyword\"),\n  schemaPath: new Name(\"schemaPath\"), // also used in JTD errors\n  params: new Name(\"params\"),\n  propertyName: new Name(\"propertyName\"),\n  message: new Name(\"message\"),\n  schema: new Name(\"schema\"),\n  parentSchema: new Name(\"parentSchema\"),\n}\n\nfunction errorObjectCode(\n  cxt: KeywordErrorCxt,\n  error: KeywordErrorDefinition,\n  errorPaths?: ErrorPaths\n): Code {\n  const {createErrors} = cxt.it\n  if (createErrors === false) return _`{}`\n  return errorObject(cxt, error, errorPaths)\n}\n\nfunction errorObject(\n  cxt: KeywordErrorCxt,\n  error: KeywordErrorDefinition,\n  errorPaths: ErrorPaths = {}\n): Code {\n  const {gen, it} = cxt\n  const keyValues: [Name, SafeExpr | string][] = [\n    errorInstancePath(it, errorPaths),\n    errorSchemaPath(cxt, errorPaths),\n  ]\n  extraErrorProps(cxt, error, keyValues)\n  return gen.object(...keyValues)\n}\n\nfunction errorInstancePath({errorPath}: SchemaCxt, {instancePath}: ErrorPaths): [Name, Code] {\n  const instPath = instancePath\n    ? str`${errorPath}${getErrorPath(instancePath, Type.Str)}`\n    : errorPath\n  return [N.instancePath, strConcat(N.instancePath, instPath)]\n}\n\nfunction errorSchemaPath(\n  {keyword, it: {errSchemaPath}}: KeywordErrorCxt,\n  {schemaPath, parentSchema}: ErrorPaths\n): [Name, string | Code] {\n  let schPath = parentSchema ? errSchemaPath : str`${errSchemaPath}/${keyword}`\n  if (schemaPath) {\n    schPath = str`${schPath}${getErrorPath(schemaPath, Type.Str)}`\n  }\n  return [E.schemaPath, schPath]\n}\n\nfunction extraErrorProps(\n  cxt: KeywordErrorCxt,\n  {params, message}: KeywordErrorDefinition,\n  keyValues: [Name, SafeExpr | string][]\n): void {\n  const {keyword, data, schemaValue, it} = cxt\n  const {opts, propertyName, topSchemaRef, schemaPath} = it\n  keyValues.push(\n    [E.keyword, keyword],\n    [E.params, typeof params == \"function\" ? params(cxt) : params || _`{}`]\n  )\n  if (opts.messages) {\n    keyValues.push([E.message, typeof message == \"function\" ? message(cxt) : message])\n  }\n  if (opts.verbose) {\n    keyValues.push(\n      [E.schema, schemaValue],\n      [E.parentSchema, _`${topSchemaRef}${schemaPath}`],\n      [N.data, data]\n    )\n  }\n  if (propertyName) keyValues.push([E.propertyName, propertyName])\n}\n","import type {\n  AnySchema,\n  AnySchemaObject,\n  AnyValidateFunction,\n  AsyncValidateFunction,\n  EvaluatedProperties,\n  EvaluatedItems,\n} from \"../types\"\nimport type Ajv from \"../core\"\nimport type {InstanceOptions} from \"../core\"\nimport {CodeGen, _, nil, stringify, Name, Code, ValueScopeName} from \"./codegen\"\nimport ValidationError from \"../runtime/validation_error\"\nimport N from \"./names\"\nimport {LocalRefs, getFullPath, _getFullPath, inlineRef, normalizeId, resolveUrl} from \"./resolve\"\nimport {schemaHasRulesButRef, unescapeFragment} from \"./util\"\nimport {validateFunctionCode} from \"./validate\"\nimport {URIComponent} from \"fast-uri\"\nimport {JSONType} from \"./rules\"\n\nexport type SchemaRefs = {\n  [Ref in string]?: SchemaEnv | AnySchema\n}\n\nexport interface SchemaCxt {\n  readonly gen: CodeGen\n  readonly allErrors?: boolean // validation mode - whether to collect all errors or break on error\n  readonly data: Name // Name with reference to the current part of data instance\n  readonly parentData: Name // should be used in keywords modifying data\n  readonly parentDataProperty: Code | number // should be used in keywords modifying data\n  readonly dataNames: Name[]\n  readonly dataPathArr: (Code | number)[]\n  readonly dataLevel: number // the level of the currently validated data,\n  // it can be used to access both the property names and the data on all levels from the top.\n  dataTypes: JSONType[] // data types applied to the current part of data instance\n  definedProperties: Set<string> // set of properties to keep track of for required checks\n  readonly topSchemaRef: Code\n  readonly validateName: Name\n  evaluated?: Name\n  readonly ValidationError?: Name\n  readonly schema: AnySchema // current schema object - equal to parentSchema passed via KeywordCxt\n  readonly schemaEnv: SchemaEnv\n  readonly rootId: string\n  baseId: string // the current schema base URI that should be used as the base for resolving URIs in references (\\$ref)\n  readonly schemaPath: Code // the run-time expression that evaluates to the property name of the current schema\n  readonly errSchemaPath: string // this is actual string, should not be changed to Code\n  readonly errorPath: Code\n  readonly propertyName?: Name\n  readonly compositeRule?: boolean // true indicates that the current schema is inside the compound keyword,\n  // where failing some rule doesn't mean validation failure (`anyOf`, `oneOf`, `not`, `if`).\n  // This flag is used to determine whether you can return validation result immediately after any error in case the option `allErrors` is not `true.\n  // You only need to use it if you have many steps in your keywords and potentially can define multiple errors.\n  props?: EvaluatedProperties | Name // properties evaluated by this schema - used by parent schema or assigned to validation function\n  items?: EvaluatedItems | Name // last item evaluated by this schema - used by parent schema or assigned to validation function\n  jtdDiscriminator?: string\n  jtdMetadata?: boolean\n  readonly createErrors?: boolean\n  readonly opts: InstanceOptions // Ajv instance option.\n  readonly self: Ajv // current Ajv instance\n}\n\nexport interface SchemaObjCxt extends SchemaCxt {\n  readonly schema: AnySchemaObject\n}\ninterface SchemaEnvArgs {\n  readonly schema: AnySchema\n  readonly schemaId?: \"$id\" | \"id\"\n  readonly root?: SchemaEnv\n  readonly baseId?: string\n  readonly schemaPath?: string\n  readonly localRefs?: LocalRefs\n  readonly meta?: boolean\n}\n\nexport class SchemaEnv implements SchemaEnvArgs {\n  readonly schema: AnySchema\n  readonly schemaId?: \"$id\" | \"id\"\n  readonly root: SchemaEnv\n  baseId: string // TODO possibly, it should be readonly\n  schemaPath?: string\n  localRefs?: LocalRefs\n  readonly meta?: boolean\n  readonly $async?: boolean // true if the current schema is asynchronous.\n  readonly refs: SchemaRefs = {}\n  readonly dynamicAnchors: {[Ref in string]?: true} = {}\n  validate?: AnyValidateFunction\n  validateName?: ValueScopeName\n  serialize?: (data: unknown) => string\n  serializeName?: ValueScopeName\n  parse?: (data: string) => unknown\n  parseName?: ValueScopeName\n\n  constructor(env: SchemaEnvArgs) {\n    let schema: AnySchemaObject | undefined\n    if (typeof env.schema == \"object\") schema = env.schema\n    this.schema = env.schema\n    this.schemaId = env.schemaId\n    this.root = env.root || this\n    this.baseId = env.baseId ?? normalizeId(schema?.[env.schemaId || \"$id\"])\n    this.schemaPath = env.schemaPath\n    this.localRefs = env.localRefs\n    this.meta = env.meta\n    this.$async = schema?.$async\n    this.refs = {}\n  }\n}\n\n// let codeSize = 0\n// let nodeCount = 0\n\n// Compiles schema in SchemaEnv\nexport function compileSchema(this: Ajv, sch: SchemaEnv): SchemaEnv {\n  // TODO refactor - remove compilations\n  const _sch = getCompilingSchema.call(this, sch)\n  if (_sch) return _sch\n  const rootId = getFullPath(this.opts.uriResolver, sch.root.baseId) // TODO if getFullPath removed 1 tests fails\n  const {es5, lines} = this.opts.code\n  const {ownProperties} = this.opts\n  const gen = new CodeGen(this.scope, {es5, lines, ownProperties})\n  let _ValidationError\n  if (sch.$async) {\n    _ValidationError = gen.scopeValue(\"Error\", {\n      ref: ValidationError,\n      code: _`require(\"ajv/dist/runtime/validation_error\").default`,\n    })\n  }\n\n  const validateName = gen.scopeName(\"validate\")\n  sch.validateName = validateName\n\n  const schemaCxt: SchemaCxt = {\n    gen,\n    allErrors: this.opts.allErrors,\n    data: N.data,\n    parentData: N.parentData,\n    parentDataProperty: N.parentDataProperty,\n    dataNames: [N.data],\n    dataPathArr: [nil], // TODO can its length be used as dataLevel if nil is removed?\n    dataLevel: 0,\n    dataTypes: [],\n    definedProperties: new Set<string>(),\n    topSchemaRef: gen.scopeValue(\n      \"schema\",\n      this.opts.code.source === true\n        ? {ref: sch.schema, code: stringify(sch.schema)}\n        : {ref: sch.schema}\n    ),\n    validateName,\n    ValidationError: _ValidationError,\n    schema: sch.schema,\n    schemaEnv: sch,\n    rootId,\n    baseId: sch.baseId || rootId,\n    schemaPath: nil,\n    errSchemaPath: sch.schemaPath || (this.opts.jtd ? \"\" : \"#\"),\n    errorPath: _`\"\"`,\n    opts: this.opts,\n    self: this,\n  }\n\n  let sourceCode: string | undefined\n  try {\n    this._compilations.add(sch)\n    validateFunctionCode(schemaCxt)\n    gen.optimize(this.opts.code.optimize)\n    // gen.optimize(1)\n    const validateCode = gen.toString()\n    sourceCode = `${gen.scopeRefs(N.scope)}return ${validateCode}`\n    // console.log((codeSize += sourceCode.length), (nodeCount += gen.nodeCount))\n    if (this.opts.code.process) sourceCode = this.opts.code.process(sourceCode, sch)\n    // console.log(\"\\n\\n\\n *** \\n\", sourceCode)\n    const makeValidate = new Function(`${N.self}`, `${N.scope}`, sourceCode)\n    const validate: AnyValidateFunction = makeValidate(this, this.scope.get())\n    this.scope.value(validateName, {ref: validate})\n\n    validate.errors = null\n    validate.schema = sch.schema\n    validate.schemaEnv = sch\n    if (sch.$async) (validate as AsyncValidateFunction).$async = true\n    if (this.opts.code.source === true) {\n      validate.source = {validateName, validateCode, scopeValues: gen._values}\n    }\n    if (this.opts.unevaluated) {\n      const {props, items} = schemaCxt\n      validate.evaluated = {\n        props: props instanceof Name ? undefined : props,\n        items: items instanceof Name ? undefined : items,\n        dynamicProps: props instanceof Name,\n        dynamicItems: items instanceof Name,\n      }\n      if (validate.source) validate.source.evaluated = stringify(validate.evaluated)\n    }\n    sch.validate = validate\n    return sch\n  } catch (e) {\n    delete sch.validate\n    delete sch.validateName\n    if (sourceCode) this.logger.error(\"Error compiling schema, function code:\", sourceCode)\n    // console.log(\"\\n\\n\\n *** \\n\", sourceCode, this.opts)\n    throw e\n  } finally {\n    this._compilations.delete(sch)\n  }\n}\n\nexport function resolveRef(\n  this: Ajv,\n  root: SchemaEnv,\n  baseId: string,\n  ref: string\n): AnySchema | SchemaEnv | undefined {\n  ref = resolveUrl(this.opts.uriResolver, baseId, ref)\n  const schOrFunc = root.refs[ref]\n  if (schOrFunc) return schOrFunc\n\n  let _sch = resolve.call(this, root, ref)\n  if (_sch === undefined) {\n    const schema = root.localRefs?.[ref] // TODO maybe localRefs should hold SchemaEnv\n    const {schemaId} = this.opts\n    if (schema) _sch = new SchemaEnv({schema, schemaId, root, baseId})\n  }\n\n  if (_sch === undefined) return\n  return (root.refs[ref] = inlineOrCompile.call(this, _sch))\n}\n\nfunction inlineOrCompile(this: Ajv, sch: SchemaEnv): AnySchema | SchemaEnv {\n  if (inlineRef(sch.schema, this.opts.inlineRefs)) return sch.schema\n  return sch.validate ? sch : compileSchema.call(this, sch)\n}\n\n// Index of schema compilation in the currently compiled list\nexport function getCompilingSchema(this: Ajv, schEnv: SchemaEnv): SchemaEnv | void {\n  for (const sch of this._compilations) {\n    if (sameSchemaEnv(sch, schEnv)) return sch\n  }\n}\n\nfunction sameSchemaEnv(s1: SchemaEnv, s2: SchemaEnv): boolean {\n  return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId\n}\n\n// resolve and compile the references ($ref)\n// TODO returns AnySchemaObject (if the schema can be inlined) or validation function\nfunction resolve(\n  this: Ajv,\n  root: SchemaEnv, // information about the root schema for the current schema\n  ref: string // reference to resolve\n): SchemaEnv | undefined {\n  let sch\n  while (typeof (sch = this.refs[ref]) == \"string\") ref = sch\n  return sch || this.schemas[ref] || resolveSchema.call(this, root, ref)\n}\n\n// Resolve schema, its root and baseId\nexport function resolveSchema(\n  this: Ajv,\n  root: SchemaEnv, // root object with properties schema, refs TODO below SchemaEnv is assigned to it\n  ref: string // reference to resolve\n): SchemaEnv | undefined {\n  const p = this.opts.uriResolver.parse(ref)\n  const refPath = _getFullPath(this.opts.uriResolver, p)\n  let baseId = getFullPath(this.opts.uriResolver, root.baseId, undefined)\n  // TODO `Object.keys(root.schema).length > 0` should not be needed - but removing breaks 2 tests\n  if (Object.keys(root.schema).length > 0 && refPath === baseId) {\n    return getJsonPointer.call(this, p, root)\n  }\n\n  const id = normalizeId(refPath)\n  const schOrRef = this.refs[id] || this.schemas[id]\n  if (typeof schOrRef == \"string\") {\n    const sch = resolveSchema.call(this, root, schOrRef)\n    if (typeof sch?.schema !== \"object\") return\n    return getJsonPointer.call(this, p, sch)\n  }\n\n  if (typeof schOrRef?.schema !== \"object\") return\n  if (!schOrRef.validate) compileSchema.call(this, schOrRef)\n  if (id === normalizeId(ref)) {\n    const {schema} = schOrRef\n    const {schemaId} = this.opts\n    const schId = schema[schemaId]\n    if (schId) baseId = resolveUrl(this.opts.uriResolver, baseId, schId)\n    return new SchemaEnv({schema, schemaId, root, baseId})\n  }\n  return getJsonPointer.call(this, p, schOrRef)\n}\n\nconst PREVENT_SCOPE_CHANGE = new Set([\n  \"properties\",\n  \"patternProperties\",\n  \"enum\",\n  \"dependencies\",\n  \"definitions\",\n])\n\nfunction getJsonPointer(\n  this: Ajv,\n  parsedRef: URIComponent,\n  {baseId, schema, root}: SchemaEnv\n): SchemaEnv | undefined {\n  if (parsedRef.fragment?.[0] !== \"/\") return\n  for (const part of parsedRef.fragment.slice(1).split(\"/\")) {\n    if (typeof schema === \"boolean\") return\n    const partSchema = schema[unescapeFragment(part)]\n    if (partSchema === undefined) return\n    schema = partSchema\n    // TODO PREVENT_SCOPE_CHANGE could be defined in keyword def?\n    const schId = typeof schema === \"object\" && schema[this.opts.schemaId]\n    if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {\n      baseId = resolveUrl(this.opts.uriResolver, baseId, schId)\n    }\n  }\n  let env: SchemaEnv | undefined\n  if (typeof schema != \"boolean\" && schema.$ref && !schemaHasRulesButRef(schema, this.RULES)) {\n    const $ref = resolveUrl(this.opts.uriResolver, baseId, schema.$ref)\n    env = resolveSchema.call(this, root, $ref)\n  }\n  // even though resolution failed we need to return SchemaEnv to throw exception\n  // so that compileAsync loads missing schema.\n  const {schemaId} = this.opts\n  env = env || new SchemaEnv({schema, schemaId, root, baseId})\n  if (env.schema !== env.root.schema) return env\n  return undefined\n}\n","import {Name} from \"./codegen\"\n\nconst names = {\n  // validation function arguments\n  data: new Name(\"data\"), // data passed to validation function\n  // args passed from referencing schema\n  valCxt: new Name(\"valCxt\"), // validation/data context - should not be used directly, it is destructured to the names below\n  instancePath: new Name(\"instancePath\"),\n  parentData: new Name(\"parentData\"),\n  parentDataProperty: new Name(\"parentDataProperty\"),\n  rootData: new Name(\"rootData\"), // root data - same as the data passed to the first/top validation function\n  dynamicAnchors: new Name(\"dynamicAnchors\"), // used to support recursiveRef and dynamicRef\n  // function scoped variables\n  vErrors: new Name(\"vErrors\"), // null or array of validation errors\n  errors: new Name(\"errors\"), // counter of validation errors\n  this: new Name(\"this\"),\n  // \"globals\"\n  self: new Name(\"self\"),\n  scope: new Name(\"scope\"),\n  // JTD serialize/parse name for JSON string and position\n  json: new Name(\"json\"),\n  jsonPos: new Name(\"jsonPos\"),\n  jsonLen: new Name(\"jsonLen\"),\n  jsonPart: new Name(\"jsonPart\"),\n}\n\nexport default names\n","import {resolveUrl, normalizeId, getFullPath} from \"./resolve\"\nimport type {UriResolver} from \"../types\"\n\nexport default class MissingRefError extends Error {\n  readonly missingRef: string\n  readonly missingSchema: string\n\n  constructor(resolver: UriResolver, baseId: string, ref: string, msg?: string) {\n    super(msg || `can't resolve reference ${ref} from id ${baseId}`)\n    this.missingRef = resolveUrl(resolver, baseId, ref)\n    this.missingSchema = normalizeId(getFullPath(resolver, this.missingRef))\n  }\n}\n","import type {AnySchema, AnySchemaObject, UriResolver} from \"../types\"\nimport type Ajv from \"../ajv\"\nimport type {URIComponent} from \"fast-uri\"\nimport {eachItem} from \"./util\"\nimport * as equal from \"fast-deep-equal\"\nimport * as traverse from \"json-schema-traverse\"\n\n// the hash of local references inside the schema (created by getSchemaRefs), used for inline resolution\nexport type LocalRefs = {[Ref in string]?: AnySchemaObject}\n\n// TODO refactor to use keyword definitions\nconst SIMPLE_INLINED = new Set([\n  \"type\",\n  \"format\",\n  \"pattern\",\n  \"maxLength\",\n  \"minLength\",\n  \"maxProperties\",\n  \"minProperties\",\n  \"maxItems\",\n  \"minItems\",\n  \"maximum\",\n  \"minimum\",\n  \"uniqueItems\",\n  \"multipleOf\",\n  \"required\",\n  \"enum\",\n  \"const\",\n])\n\nexport function inlineRef(schema: AnySchema, limit: boolean | number = true): boolean {\n  if (typeof schema == \"boolean\") return true\n  if (limit === true) return !hasRef(schema)\n  if (!limit) return false\n  return countKeys(schema) <= limit\n}\n\nconst REF_KEYWORDS = new Set([\n  \"$ref\",\n  \"$recursiveRef\",\n  \"$recursiveAnchor\",\n  \"$dynamicRef\",\n  \"$dynamicAnchor\",\n])\n\nfunction hasRef(schema: AnySchemaObject): boolean {\n  for (const key in schema) {\n    if (REF_KEYWORDS.has(key)) return true\n    const sch = schema[key]\n    if (Array.isArray(sch) && sch.some(hasRef)) return true\n    if (typeof sch == \"object\" && hasRef(sch)) return true\n  }\n  return false\n}\n\nfunction countKeys(schema: AnySchemaObject): number {\n  let count = 0\n  for (const key in schema) {\n    if (key === \"$ref\") return Infinity\n    count++\n    if (SIMPLE_INLINED.has(key)) continue\n    if (typeof schema[key] == \"object\") {\n      eachItem(schema[key], (sch) => (count += countKeys(sch)))\n    }\n    if (count === Infinity) return Infinity\n  }\n  return count\n}\n\nexport function getFullPath(resolver: UriResolver, id = \"\", normalize?: boolean): string {\n  if (normalize !== false) id = normalizeId(id)\n  const p = resolver.parse(id)\n  return _getFullPath(resolver, p)\n}\n\nexport function _getFullPath(resolver: UriResolver, p: URIComponent): string {\n  const serialized = resolver.serialize(p)\n  return serialized.split(\"#\")[0] + \"#\"\n}\n\nconst TRAILING_SLASH_HASH = /#\\/?$/\nexport function normalizeId(id: string | undefined): string {\n  return id ? id.replace(TRAILING_SLASH_HASH, \"\") : \"\"\n}\n\nexport function resolveUrl(resolver: UriResolver, baseId: string, id: string): string {\n  id = normalizeId(id)\n  return resolver.resolve(baseId, id)\n}\n\nconst ANCHOR = /^[a-z_][-a-z0-9._]*$/i\n\nexport function getSchemaRefs(this: Ajv, schema: AnySchema, baseId: string): LocalRefs {\n  if (typeof schema == \"boolean\") return {}\n  const {schemaId, uriResolver} = this.opts\n  const schId = normalizeId(schema[schemaId] || baseId)\n  const baseIds: {[JsonPtr in string]?: string} = {\"\": schId}\n  const pathPrefix = getFullPath(uriResolver, schId, false)\n  const localRefs: LocalRefs = {}\n  const schemaRefs: Set<string> = new Set()\n\n  traverse(schema, {allKeys: true}, (sch, jsonPtr, _, parentJsonPtr) => {\n    if (parentJsonPtr === undefined) return\n    const fullPath = pathPrefix + jsonPtr\n    let innerBaseId = baseIds[parentJsonPtr]\n    if (typeof sch[schemaId] == \"string\") innerBaseId = addRef.call(this, sch[schemaId])\n    addAnchor.call(this, sch.$anchor)\n    addAnchor.call(this, sch.$dynamicAnchor)\n    baseIds[jsonPtr] = innerBaseId\n\n    function addRef(this: Ajv, ref: string): string {\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      const _resolve = this.opts.uriResolver.resolve\n      ref = normalizeId(innerBaseId ? _resolve(innerBaseId, ref) : ref)\n      if (schemaRefs.has(ref)) throw ambiguos(ref)\n      schemaRefs.add(ref)\n      let schOrRef = this.refs[ref]\n      if (typeof schOrRef == \"string\") schOrRef = this.refs[schOrRef]\n      if (typeof schOrRef == \"object\") {\n        checkAmbiguosRef(sch, schOrRef.schema, ref)\n      } else if (ref !== normalizeId(fullPath)) {\n        if (ref[0] === \"#\") {\n          checkAmbiguosRef(sch, localRefs[ref], ref)\n          localRefs[ref] = sch\n        } else {\n          this.refs[ref] = fullPath\n        }\n      }\n      return ref\n    }\n\n    function addAnchor(this: Ajv, anchor: unknown): void {\n      if (typeof anchor == \"string\") {\n        if (!ANCHOR.test(anchor)) throw new Error(`invalid anchor \"${anchor}\"`)\n        addRef.call(this, `#${anchor}`)\n      }\n    }\n  })\n\n  return localRefs\n\n  function checkAmbiguosRef(sch1: AnySchema, sch2: AnySchema | undefined, ref: string): void {\n    if (sch2 !== undefined && !equal(sch1, sch2)) throw ambiguos(ref)\n  }\n\n  function ambiguos(ref: string): Error {\n    return new Error(`reference \"${ref}\" resolves to more than one schema`)\n  }\n}\n","import type {AddedKeywordDefinition} from \"../types\"\n\nconst _jsonTypes = [\"string\", \"number\", \"integer\", \"boolean\", \"null\", \"object\", \"array\"] as const\n\nexport type JSONType = (typeof _jsonTypes)[number]\n\nconst jsonTypes: Set<string> = new Set(_jsonTypes)\n\nexport function isJSONType(x: unknown): x is JSONType {\n  return typeof x == \"string\" && jsonTypes.has(x)\n}\n\ntype ValidationTypes = {\n  [K in JSONType]: boolean | RuleGroup | undefined\n}\n\nexport interface ValidationRules {\n  rules: RuleGroup[]\n  post: RuleGroup\n  all: {[Key in string]?: boolean | Rule} // rules that have to be validated\n  keywords: {[Key in string]?: boolean} // all known keywords (superset of \"all\")\n  types: ValidationTypes\n}\n\nexport interface RuleGroup {\n  type?: JSONType\n  rules: Rule[]\n}\n\n// This interface wraps KeywordDefinition because definition can have multiple keywords\nexport interface Rule {\n  keyword: string\n  definition: AddedKeywordDefinition\n}\n\nexport function getRules(): ValidationRules {\n  const groups: Record<\"number\" | \"string\" | \"array\" | \"object\", RuleGroup> = {\n    number: {type: \"number\", rules: []},\n    string: {type: \"string\", rules: []},\n    array: {type: \"array\", rules: []},\n    object: {type: \"object\", rules: []},\n  }\n  return {\n    types: {...groups, integer: true, boolean: true, null: true},\n    rules: [{rules: []}, groups.number, groups.string, groups.array, groups.object],\n    post: {rules: []},\n    all: {},\n    keywords: {},\n  }\n}\n","import type {AnySchema, EvaluatedProperties, EvaluatedItems} from \"../types\"\nimport type {SchemaCxt, SchemaObjCxt} from \".\"\nimport {_, getProperty, Code, Name, CodeGen} from \"./codegen\"\nimport {_Code} from \"./codegen/code\"\nimport type {Rule, ValidationRules} from \"./rules\"\n\n// TODO refactor to use Set\nexport function toHash<T extends string = string>(arr: T[]): {[K in T]?: true} {\n  const hash: {[K in T]?: true} = {}\n  for (const item of arr) hash[item] = true\n  return hash\n}\n\nexport function alwaysValidSchema(it: SchemaCxt, schema: AnySchema): boolean | void {\n  if (typeof schema == \"boolean\") return schema\n  if (Object.keys(schema).length === 0) return true\n  checkUnknownRules(it, schema)\n  return !schemaHasRules(schema, it.self.RULES.all)\n}\n\nexport function checkUnknownRules(it: SchemaCxt, schema: AnySchema = it.schema): void {\n  const {opts, self} = it\n  if (!opts.strictSchema) return\n  if (typeof schema === \"boolean\") return\n  const rules = self.RULES.keywords\n  for (const key in schema) {\n    if (!rules[key]) checkStrictMode(it, `unknown keyword: \"${key}\"`)\n  }\n}\n\nexport function schemaHasRules(\n  schema: AnySchema,\n  rules: {[Key in string]?: boolean | Rule}\n): boolean {\n  if (typeof schema == \"boolean\") return !schema\n  for (const key in schema) if (rules[key]) return true\n  return false\n}\n\nexport function schemaHasRulesButRef(schema: AnySchema, RULES: ValidationRules): boolean {\n  if (typeof schema == \"boolean\") return !schema\n  for (const key in schema) if (key !== \"$ref\" && RULES.all[key]) return true\n  return false\n}\n\nexport function schemaRefOrVal(\n  {topSchemaRef, schemaPath}: SchemaObjCxt,\n  schema: unknown,\n  keyword: string,\n  $data?: string | false\n): Code | number | boolean {\n  if (!$data) {\n    if (typeof schema == \"number\" || typeof schema == \"boolean\") return schema\n    if (typeof schema == \"string\") return _`${schema}`\n  }\n  return _`${topSchemaRef}${schemaPath}${getProperty(keyword)}`\n}\n\nexport function unescapeFragment(str: string): string {\n  return unescapeJsonPointer(decodeURIComponent(str))\n}\n\nexport function escapeFragment(str: string | number): string {\n  return encodeURIComponent(escapeJsonPointer(str))\n}\n\nexport function escapeJsonPointer(str: string | number): string {\n  if (typeof str == \"number\") return `${str}`\n  return str.replace(/~/g, \"~0\").replace(/\\//g, \"~1\")\n}\n\nexport function unescapeJsonPointer(str: string): string {\n  return str.replace(/~1/g, \"/\").replace(/~0/g, \"~\")\n}\n\nexport function eachItem<T>(xs: T | T[], f: (x: T) => void): void {\n  if (Array.isArray(xs)) {\n    for (const x of xs) f(x)\n  } else {\n    f(xs)\n  }\n}\n\ntype SomeEvaluated = EvaluatedProperties | EvaluatedItems\n\ntype MergeEvaluatedFunc<T extends SomeEvaluated> = (\n  gen: CodeGen,\n  from: Name | T,\n  to: Name | Exclude<T, true> | undefined,\n  toName?: typeof Name\n) => Name | T\n\ninterface MakeMergeFuncArgs<T extends SomeEvaluated> {\n  mergeNames: (gen: CodeGen, from: Name, to: Name) => void\n  mergeToName: (gen: CodeGen, from: T, to: Name) => void\n  mergeValues: (from: T, to: Exclude<T, true>) => T\n  resultToName: (gen: CodeGen, res?: T) => Name\n}\n\nfunction makeMergeEvaluated<T extends SomeEvaluated>({\n  mergeNames,\n  mergeToName,\n  mergeValues,\n  resultToName,\n}: MakeMergeFuncArgs<T>): MergeEvaluatedFunc<T> {\n  return (gen, from, to, toName) => {\n    const res =\n      to === undefined\n        ? from\n        : to instanceof Name\n        ? (from instanceof Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to)\n        : from instanceof Name\n        ? (mergeToName(gen, to, from), from)\n        : mergeValues(from, to)\n    return toName === Name && !(res instanceof Name) ? resultToName(gen, res) : res\n  }\n}\n\ninterface MergeEvaluated {\n  props: MergeEvaluatedFunc<EvaluatedProperties>\n  items: MergeEvaluatedFunc<EvaluatedItems>\n}\n\nexport const mergeEvaluated: MergeEvaluated = {\n  props: makeMergeEvaluated({\n    mergeNames: (gen, from, to) =>\n      gen.if(_`${to} !== true && ${from} !== undefined`, () => {\n        gen.if(\n          _`${from} === true`,\n          () => gen.assign(to, true),\n          () => gen.assign(to, _`${to} || {}`).code(_`Object.assign(${to}, ${from})`)\n        )\n      }),\n    mergeToName: (gen, from, to) =>\n      gen.if(_`${to} !== true`, () => {\n        if (from === true) {\n          gen.assign(to, true)\n        } else {\n          gen.assign(to, _`${to} || {}`)\n          setEvaluated(gen, to, from)\n        }\n      }),\n    mergeValues: (from, to) => (from === true ? true : {...from, ...to}),\n    resultToName: evaluatedPropsToName,\n  }),\n  items: makeMergeEvaluated({\n    mergeNames: (gen, from, to) =>\n      gen.if(_`${to} !== true && ${from} !== undefined`, () =>\n        gen.assign(to, _`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)\n      ),\n    mergeToName: (gen, from, to) =>\n      gen.if(_`${to} !== true`, () =>\n        gen.assign(to, from === true ? true : _`${to} > ${from} ? ${to} : ${from}`)\n      ),\n    mergeValues: (from, to) => (from === true ? true : Math.max(from, to)),\n    resultToName: (gen, items) => gen.var(\"items\", items),\n  }),\n}\n\nexport function evaluatedPropsToName(gen: CodeGen, ps?: EvaluatedProperties): Name {\n  if (ps === true) return gen.var(\"props\", true)\n  const props = gen.var(\"props\", _`{}`)\n  if (ps !== undefined) setEvaluated(gen, props, ps)\n  return props\n}\n\nexport function setEvaluated(gen: CodeGen, props: Name, ps: {[K in string]?: true}): void {\n  Object.keys(ps).forEach((p) => gen.assign(_`${props}${getProperty(p)}`, true))\n}\n\nconst snippets: {[S in string]?: _Code} = {}\n\nexport function useFunc(gen: CodeGen, f: {code: string}): Name {\n  return gen.scopeValue(\"func\", {\n    ref: f,\n    code: snippets[f.code] || (snippets[f.code] = new _Code(f.code)),\n  })\n}\n\nexport enum Type {\n  Num,\n  Str,\n}\n\nexport function getErrorPath(\n  dataProp: Name | string | number,\n  dataPropType?: Type,\n  jsPropertySyntax?: boolean\n): Code | string {\n  // let path\n  if (dataProp instanceof Name) {\n    const isNumber = dataPropType === Type.Num\n    return jsPropertySyntax\n      ? isNumber\n        ? _`\"[\" + ${dataProp} + \"]\"`\n        : _`\"['\" + ${dataProp} + \"']\"`\n      : isNumber\n      ? _`\"/\" + ${dataProp}`\n      : _`\"/\" + ${dataProp}.replace(/~/g, \"~0\").replace(/\\\\//g, \"~1\")` // TODO maybe use global escapePointer\n  }\n  return jsPropertySyntax ? getProperty(dataProp).toString() : \"/\" + escapeJsonPointer(dataProp)\n}\n\nexport function checkStrictMode(\n  it: SchemaCxt,\n  msg: string,\n  mode: boolean | \"log\" = it.opts.strictSchema\n): void {\n  if (!mode) return\n  msg = `strict mode: ${msg}`\n  if (mode === true) throw new Error(msg)\n  it.self.logger.warn(msg)\n}\n","import type {AnySchemaObject} from \"../../types\"\nimport type {SchemaObjCxt} from \"..\"\nimport type {JSONType, RuleGroup, Rule} from \"../rules\"\n\nexport function schemaHasRulesForType(\n  {schema, self}: SchemaObjCxt,\n  type: JSONType\n): boolean | undefined {\n  const group = self.RULES.types[type]\n  return group && group !== true && shouldUseGroup(schema, group)\n}\n\nexport function shouldUseGroup(schema: AnySchemaObject, group: RuleGroup): boolean {\n  return group.rules.some((rule) => shouldUseRule(schema, rule))\n}\n\nexport function shouldUseRule(schema: AnySchemaObject, rule: Rule): boolean | undefined {\n  return (\n    schema[rule.keyword] !== undefined ||\n    rule.definition.implements?.some((kwd) => schema[kwd] !== undefined)\n  )\n}\n","import type {KeywordErrorDefinition, KeywordErrorCxt} from \"../../types\"\nimport type {SchemaCxt} from \"..\"\nimport {reportError} from \"../errors\"\nimport {_, Name} from \"../codegen\"\nimport N from \"../names\"\n\nconst boolError: KeywordErrorDefinition = {\n  message: \"boolean schema is false\",\n}\n\nexport function topBoolOrEmptySchema(it: SchemaCxt): void {\n  const {gen, schema, validateName} = it\n  if (schema === false) {\n    falseSchemaError(it, false)\n  } else if (typeof schema == \"object\" && schema.$async === true) {\n    gen.return(N.data)\n  } else {\n    gen.assign(_`${validateName}.errors`, null)\n    gen.return(true)\n  }\n}\n\nexport function boolOrEmptySchema(it: SchemaCxt, valid: Name): void {\n  const {gen, schema} = it\n  if (schema === false) {\n    gen.var(valid, false) // TODO var\n    falseSchemaError(it)\n  } else {\n    gen.var(valid, true) // TODO var\n  }\n}\n\nfunction falseSchemaError(it: SchemaCxt, overrideAllErrors?: boolean): void {\n  const {gen, data} = it\n  // TODO maybe some other interface should be used for non-keyword validation errors...\n  const cxt: KeywordErrorCxt = {\n    gen,\n    keyword: \"false schema\",\n    data,\n    schema: false,\n    schemaCode: false,\n    schemaValue: false,\n    params: {},\n    it,\n  }\n  reportError(cxt, boolError, undefined, overrideAllErrors)\n}\n","import type {\n  KeywordErrorDefinition,\n  KeywordErrorCxt,\n  ErrorObject,\n  AnySchemaObject,\n} from \"../../types\"\nimport type {SchemaObjCxt} from \"..\"\nimport {isJSONType, JSONType} from \"../rules\"\nimport {schemaHasRulesForType} from \"./applicability\"\nimport {reportError} from \"../errors\"\nimport {_, nil, and, not, operators, Code, Name} from \"../codegen\"\nimport {toHash, schemaRefOrVal} from \"../util\"\n\nexport enum DataType {\n  Correct,\n  Wrong,\n}\n\nexport function getSchemaTypes(schema: AnySchemaObject): JSONType[] {\n  const types = getJSONTypes(schema.type)\n  const hasNull = types.includes(\"null\")\n  if (hasNull) {\n    if (schema.nullable === false) throw new Error(\"type: null contradicts nullable: false\")\n  } else {\n    if (!types.length && schema.nullable !== undefined) {\n      throw new Error('\"nullable\" cannot be used without \"type\"')\n    }\n    if (schema.nullable === true) types.push(\"null\")\n  }\n  return types\n}\n\n// eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\nexport function getJSONTypes(ts: unknown | unknown[]): JSONType[] {\n  const types: unknown[] = Array.isArray(ts) ? ts : ts ? [ts] : []\n  if (types.every(isJSONType)) return types\n  throw new Error(\"type must be JSONType or JSONType[]: \" + types.join(\",\"))\n}\n\nexport function coerceAndCheckDataType(it: SchemaObjCxt, types: JSONType[]): boolean {\n  const {gen, data, opts} = it\n  const coerceTo = coerceToTypes(types, opts.coerceTypes)\n  const checkTypes =\n    types.length > 0 &&\n    !(coerceTo.length === 0 && types.length === 1 && schemaHasRulesForType(it, types[0]))\n  if (checkTypes) {\n    const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong)\n    gen.if(wrongType, () => {\n      if (coerceTo.length) coerceData(it, types, coerceTo)\n      else reportTypeError(it)\n    })\n  }\n  return checkTypes\n}\n\nconst COERCIBLE: Set<JSONType> = new Set([\"string\", \"number\", \"integer\", \"boolean\", \"null\"])\nfunction coerceToTypes(types: JSONType[], coerceTypes?: boolean | \"array\"): JSONType[] {\n  return coerceTypes\n    ? types.filter((t) => COERCIBLE.has(t) || (coerceTypes === \"array\" && t === \"array\"))\n    : []\n}\n\nfunction coerceData(it: SchemaObjCxt, types: JSONType[], coerceTo: JSONType[]): void {\n  const {gen, data, opts} = it\n  const dataType = gen.let(\"dataType\", _`typeof ${data}`)\n  const coerced = gen.let(\"coerced\", _`undefined`)\n  if (opts.coerceTypes === \"array\") {\n    gen.if(_`${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () =>\n      gen\n        .assign(data, _`${data}[0]`)\n        .assign(dataType, _`typeof ${data}`)\n        .if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data))\n    )\n  }\n  gen.if(_`${coerced} !== undefined`)\n  for (const t of coerceTo) {\n    if (COERCIBLE.has(t) || (t === \"array\" && opts.coerceTypes === \"array\")) {\n      coerceSpecificType(t)\n    }\n  }\n  gen.else()\n  reportTypeError(it)\n  gen.endIf()\n\n  gen.if(_`${coerced} !== undefined`, () => {\n    gen.assign(data, coerced)\n    assignParentData(it, coerced)\n  })\n\n  function coerceSpecificType(t: string): void {\n    switch (t) {\n      case \"string\":\n        gen\n          .elseIf(_`${dataType} == \"number\" || ${dataType} == \"boolean\"`)\n          .assign(coerced, _`\"\" + ${data}`)\n          .elseIf(_`${data} === null`)\n          .assign(coerced, _`\"\"`)\n        return\n      case \"number\":\n        gen\n          .elseIf(\n            _`${dataType} == \"boolean\" || ${data} === null\n              || (${dataType} == \"string\" && ${data} && ${data} == +${data})`\n          )\n          .assign(coerced, _`+${data}`)\n        return\n      case \"integer\":\n        gen\n          .elseIf(\n            _`${dataType} === \"boolean\" || ${data} === null\n              || (${dataType} === \"string\" && ${data} && ${data} == +${data} && !(${data} % 1))`\n          )\n          .assign(coerced, _`+${data}`)\n        return\n      case \"boolean\":\n        gen\n          .elseIf(_`${data} === \"false\" || ${data} === 0 || ${data} === null`)\n          .assign(coerced, false)\n          .elseIf(_`${data} === \"true\" || ${data} === 1`)\n          .assign(coerced, true)\n        return\n      case \"null\":\n        gen.elseIf(_`${data} === \"\" || ${data} === 0 || ${data} === false`)\n        gen.assign(coerced, null)\n        return\n\n      case \"array\":\n        gen\n          .elseIf(\n            _`${dataType} === \"string\" || ${dataType} === \"number\"\n              || ${dataType} === \"boolean\" || ${data} === null`\n          )\n          .assign(coerced, _`[${data}]`)\n    }\n  }\n}\n\nfunction assignParentData({gen, parentData, parentDataProperty}: SchemaObjCxt, expr: Name): void {\n  // TODO use gen.property\n  gen.if(_`${parentData} !== undefined`, () =>\n    gen.assign(_`${parentData}[${parentDataProperty}]`, expr)\n  )\n}\n\nexport function checkDataType(\n  dataType: JSONType,\n  data: Name,\n  strictNums?: boolean | \"log\",\n  correct = DataType.Correct\n): Code {\n  const EQ = correct === DataType.Correct ? operators.EQ : operators.NEQ\n  let cond: Code\n  switch (dataType) {\n    case \"null\":\n      return _`${data} ${EQ} null`\n    case \"array\":\n      cond = _`Array.isArray(${data})`\n      break\n    case \"object\":\n      cond = _`${data} && typeof ${data} == \"object\" && !Array.isArray(${data})`\n      break\n    case \"integer\":\n      cond = numCond(_`!(${data} % 1) && !isNaN(${data})`)\n      break\n    case \"number\":\n      cond = numCond()\n      break\n    default:\n      return _`typeof ${data} ${EQ} ${dataType}`\n  }\n  return correct === DataType.Correct ? cond : not(cond)\n\n  function numCond(_cond: Code = nil): Code {\n    return and(_`typeof ${data} == \"number\"`, _cond, strictNums ? _`isFinite(${data})` : nil)\n  }\n}\n\nexport function checkDataTypes(\n  dataTypes: JSONType[],\n  data: Name,\n  strictNums?: boolean | \"log\",\n  correct?: DataType\n): Code {\n  if (dataTypes.length === 1) {\n    return checkDataType(dataTypes[0], data, strictNums, correct)\n  }\n  let cond: Code\n  const types = toHash(dataTypes)\n  if (types.array && types.object) {\n    const notObj = _`typeof ${data} != \"object\"`\n    cond = types.null ? notObj : _`!${data} || ${notObj}`\n    delete types.null\n    delete types.array\n    delete types.object\n  } else {\n    cond = nil\n  }\n  if (types.number) delete types.integer\n  for (const t in types) cond = and(cond, checkDataType(t as JSONType, data, strictNums, correct))\n  return cond\n}\n\nexport type TypeError = ErrorObject<\"type\", {type: string}>\n\nconst typeError: KeywordErrorDefinition = {\n  message: ({schema}) => `must be ${schema}`,\n  params: ({schema, schemaValue}) =>\n    typeof schema == \"string\" ? _`{type: ${schema}}` : _`{type: ${schemaValue}}`,\n}\n\nexport function reportTypeError(it: SchemaObjCxt): void {\n  const cxt = getTypeErrorContext(it)\n  reportError(cxt, typeError)\n}\n\nfunction getTypeErrorContext(it: SchemaObjCxt): KeywordErrorCxt {\n  const {gen, data, schema} = it\n  const schemaCode = schemaRefOrVal(it, schema, \"type\")\n  return {\n    gen,\n    keyword: \"type\",\n    data,\n    schema: schema.type,\n    schemaCode,\n    schemaValue: schemaCode,\n    parentSchema: schema,\n    params: {},\n    it,\n  }\n}\n","import type {SchemaObjCxt} from \"..\"\nimport {_, getProperty, stringify} from \"../codegen\"\nimport {checkStrictMode} from \"../util\"\n\nexport function assignDefaults(it: SchemaObjCxt, ty?: string): void {\n  const {properties, items} = it.schema\n  if (ty === \"object\" && properties) {\n    for (const key in properties) {\n      assignDefault(it, key, properties[key].default)\n    }\n  } else if (ty === \"array\" && Array.isArray(items)) {\n    items.forEach((sch, i: number) => assignDefault(it, i, sch.default))\n  }\n}\n\nfunction assignDefault(it: SchemaObjCxt, prop: string | number, defaultValue: unknown): void {\n  const {gen, compositeRule, data, opts} = it\n  if (defaultValue === undefined) return\n  const childData = _`${data}${getProperty(prop)}`\n  if (compositeRule) {\n    checkStrictMode(it, `default is ignored for: ${childData}`)\n    return\n  }\n\n  let condition = _`${childData} === undefined`\n  if (opts.useDefaults === \"empty\") {\n    condition = _`${condition} || ${childData} === null || ${childData} === \"\"`\n  }\n  // `${childData} === undefined` +\n  // (opts.useDefaults === \"empty\" ? ` || ${childData} === null || ${childData} === \"\"` : \"\")\n  gen.if(condition, _`${childData} = ${stringify(defaultValue)}`)\n}\n","import type {\n  AddedKeywordDefinition,\n  AnySchema,\n  AnySchemaObject,\n  KeywordErrorCxt,\n  KeywordCxtParams,\n} from \"../../types\"\nimport type {SchemaCxt, SchemaObjCxt} from \"..\"\nimport type {InstanceOptions} from \"../../core\"\nimport {boolOrEmptySchema, topBoolOrEmptySchema} from \"./boolSchema\"\nimport {coerceAndCheckDataType, getSchemaTypes} from \"./dataType\"\nimport {shouldUseGroup, shouldUseRule} from \"./applicability\"\nimport {checkDataType, checkDataTypes, reportTypeError, DataType} from \"./dataType\"\nimport {assignDefaults} from \"./defaults\"\nimport {funcKeywordCode, macroKeywordCode, validateKeywordUsage, validSchemaType} from \"./keyword\"\nimport {getSubschema, extendSubschemaData, SubschemaArgs, extendSubschemaMode} from \"./subschema\"\nimport {_, nil, str, or, not, getProperty, Block, Code, Name, CodeGen} from \"../codegen\"\nimport N from \"../names\"\nimport {resolveUrl} from \"../resolve\"\nimport {\n  schemaRefOrVal,\n  schemaHasRulesButRef,\n  checkUnknownRules,\n  checkStrictMode,\n  unescapeJsonPointer,\n  mergeEvaluated,\n} from \"../util\"\nimport type {JSONType, Rule, RuleGroup} from \"../rules\"\nimport {\n  ErrorPaths,\n  reportError,\n  reportExtraError,\n  resetErrorsCount,\n  keyword$DataError,\n} from \"../errors\"\n\n// schema compilation - generates validation function, subschemaCode (below) is used for subschemas\nexport function validateFunctionCode(it: SchemaCxt): void {\n  if (isSchemaObj(it)) {\n    checkKeywords(it)\n    if (schemaCxtHasRules(it)) {\n      topSchemaObjCode(it)\n      return\n    }\n  }\n  validateFunction(it, () => topBoolOrEmptySchema(it))\n}\n\nfunction validateFunction(\n  {gen, validateName, schema, schemaEnv, opts}: SchemaCxt,\n  body: Block\n): void {\n  if (opts.code.es5) {\n    gen.func(validateName, _`${N.data}, ${N.valCxt}`, schemaEnv.$async, () => {\n      gen.code(_`\"use strict\"; ${funcSourceUrl(schema, opts)}`)\n      destructureValCxtES5(gen, opts)\n      gen.code(body)\n    })\n  } else {\n    gen.func(validateName, _`${N.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () =>\n      gen.code(funcSourceUrl(schema, opts)).code(body)\n    )\n  }\n}\n\nfunction destructureValCxt(opts: InstanceOptions): Code {\n  return _`{${N.instancePath}=\"\", ${N.parentData}, ${N.parentDataProperty}, ${N.rootData}=${\n    N.data\n  }${opts.dynamicRef ? _`, ${N.dynamicAnchors}={}` : nil}}={}`\n}\n\nfunction destructureValCxtES5(gen: CodeGen, opts: InstanceOptions): void {\n  gen.if(\n    N.valCxt,\n    () => {\n      gen.var(N.instancePath, _`${N.valCxt}.${N.instancePath}`)\n      gen.var(N.parentData, _`${N.valCxt}.${N.parentData}`)\n      gen.var(N.parentDataProperty, _`${N.valCxt}.${N.parentDataProperty}`)\n      gen.var(N.rootData, _`${N.valCxt}.${N.rootData}`)\n      if (opts.dynamicRef) gen.var(N.dynamicAnchors, _`${N.valCxt}.${N.dynamicAnchors}`)\n    },\n    () => {\n      gen.var(N.instancePath, _`\"\"`)\n      gen.var(N.parentData, _`undefined`)\n      gen.var(N.parentDataProperty, _`undefined`)\n      gen.var(N.rootData, N.data)\n      if (opts.dynamicRef) gen.var(N.dynamicAnchors, _`{}`)\n    }\n  )\n}\n\nfunction topSchemaObjCode(it: SchemaObjCxt): void {\n  const {schema, opts, gen} = it\n  validateFunction(it, () => {\n    if (opts.$comment && schema.$comment) commentKeyword(it)\n    checkNoDefault(it)\n    gen.let(N.vErrors, null)\n    gen.let(N.errors, 0)\n    if (opts.unevaluated) resetEvaluated(it)\n    typeAndKeywords(it)\n    returnResults(it)\n  })\n  return\n}\n\nfunction resetEvaluated(it: SchemaObjCxt): void {\n  // TODO maybe some hook to execute it in the end to check whether props/items are Name, as in assignEvaluated\n  const {gen, validateName} = it\n  it.evaluated = gen.const(\"evaluated\", _`${validateName}.evaluated`)\n  gen.if(_`${it.evaluated}.dynamicProps`, () => gen.assign(_`${it.evaluated}.props`, _`undefined`))\n  gen.if(_`${it.evaluated}.dynamicItems`, () => gen.assign(_`${it.evaluated}.items`, _`undefined`))\n}\n\nfunction funcSourceUrl(schema: AnySchema, opts: InstanceOptions): Code {\n  const schId = typeof schema == \"object\" && schema[opts.schemaId]\n  return schId && (opts.code.source || opts.code.process) ? _`/*# sourceURL=${schId} */` : nil\n}\n\n// schema compilation - this function is used recursively to generate code for sub-schemas\nfunction subschemaCode(it: SchemaCxt, valid: Name): void {\n  if (isSchemaObj(it)) {\n    checkKeywords(it)\n    if (schemaCxtHasRules(it)) {\n      subSchemaObjCode(it, valid)\n      return\n    }\n  }\n  boolOrEmptySchema(it, valid)\n}\n\nfunction schemaCxtHasRules({schema, self}: SchemaCxt): boolean {\n  if (typeof schema == \"boolean\") return !schema\n  for (const key in schema) if (self.RULES.all[key]) return true\n  return false\n}\n\nfunction isSchemaObj(it: SchemaCxt): it is SchemaObjCxt {\n  return typeof it.schema != \"boolean\"\n}\n\nfunction subSchemaObjCode(it: SchemaObjCxt, valid: Name): void {\n  const {schema, gen, opts} = it\n  if (opts.$comment && schema.$comment) commentKeyword(it)\n  updateContext(it)\n  checkAsyncSchema(it)\n  const errsCount = gen.const(\"_errs\", N.errors)\n  typeAndKeywords(it, errsCount)\n  // TODO var\n  gen.var(valid, _`${errsCount} === ${N.errors}`)\n}\n\nfunction checkKeywords(it: SchemaObjCxt): void {\n  checkUnknownRules(it)\n  checkRefsAndKeywords(it)\n}\n\nfunction typeAndKeywords(it: SchemaObjCxt, errsCount?: Name): void {\n  if (it.opts.jtd) return schemaKeywords(it, [], false, errsCount)\n  const types = getSchemaTypes(it.schema)\n  const checkedTypes = coerceAndCheckDataType(it, types)\n  schemaKeywords(it, types, !checkedTypes, errsCount)\n}\n\nfunction checkRefsAndKeywords(it: SchemaObjCxt): void {\n  const {schema, errSchemaPath, opts, self} = it\n  if (schema.$ref && opts.ignoreKeywordsWithRef && schemaHasRulesButRef(schema, self.RULES)) {\n    self.logger.warn(`$ref: keywords ignored in schema at path \"${errSchemaPath}\"`)\n  }\n}\n\nfunction checkNoDefault(it: SchemaObjCxt): void {\n  const {schema, opts} = it\n  if (schema.default !== undefined && opts.useDefaults && opts.strictSchema) {\n    checkStrictMode(it, \"default is ignored in the schema root\")\n  }\n}\n\nfunction updateContext(it: SchemaObjCxt): void {\n  const schId = it.schema[it.opts.schemaId]\n  if (schId) it.baseId = resolveUrl(it.opts.uriResolver, it.baseId, schId)\n}\n\nfunction checkAsyncSchema(it: SchemaObjCxt): void {\n  if (it.schema.$async && !it.schemaEnv.$async) throw new Error(\"async schema in sync schema\")\n}\n\nfunction commentKeyword({gen, schemaEnv, schema, errSchemaPath, opts}: SchemaObjCxt): void {\n  const msg = schema.$comment\n  if (opts.$comment === true) {\n    gen.code(_`${N.self}.logger.log(${msg})`)\n  } else if (typeof opts.$comment == \"function\") {\n    const schemaPath = str`${errSchemaPath}/$comment`\n    const rootName = gen.scopeValue(\"root\", {ref: schemaEnv.root})\n    gen.code(_`${N.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`)\n  }\n}\n\nfunction returnResults(it: SchemaCxt): void {\n  const {gen, schemaEnv, validateName, ValidationError, opts} = it\n  if (schemaEnv.$async) {\n    // TODO assign unevaluated\n    gen.if(\n      _`${N.errors} === 0`,\n      () => gen.return(N.data),\n      () => gen.throw(_`new ${ValidationError as Name}(${N.vErrors})`)\n    )\n  } else {\n    gen.assign(_`${validateName}.errors`, N.vErrors)\n    if (opts.unevaluated) assignEvaluated(it)\n    gen.return(_`${N.errors} === 0`)\n  }\n}\n\nfunction assignEvaluated({gen, evaluated, props, items}: SchemaCxt): void {\n  if (props instanceof Name) gen.assign(_`${evaluated}.props`, props)\n  if (items instanceof Name) gen.assign(_`${evaluated}.items`, items)\n}\n\nfunction schemaKeywords(\n  it: SchemaObjCxt,\n  types: JSONType[],\n  typeErrors: boolean,\n  errsCount?: Name\n): void {\n  const {gen, schema, data, allErrors, opts, self} = it\n  const {RULES} = self\n  if (schema.$ref && (opts.ignoreKeywordsWithRef || !schemaHasRulesButRef(schema, RULES))) {\n    gen.block(() => keywordCode(it, \"$ref\", (RULES.all.$ref as Rule).definition)) // TODO typecast\n    return\n  }\n  if (!opts.jtd) checkStrictTypes(it, types)\n  gen.block(() => {\n    for (const group of RULES.rules) groupKeywords(group)\n    groupKeywords(RULES.post)\n  })\n\n  function groupKeywords(group: RuleGroup): void {\n    if (!shouldUseGroup(schema, group)) return\n    if (group.type) {\n      gen.if(checkDataType(group.type, data, opts.strictNumbers))\n      iterateKeywords(it, group)\n      if (types.length === 1 && types[0] === group.type && typeErrors) {\n        gen.else()\n        reportTypeError(it)\n      }\n      gen.endIf()\n    } else {\n      iterateKeywords(it, group)\n    }\n    // TODO make it \"ok\" call?\n    if (!allErrors) gen.if(_`${N.errors} === ${errsCount || 0}`)\n  }\n}\n\nfunction iterateKeywords(it: SchemaObjCxt, group: RuleGroup): void {\n  const {\n    gen,\n    schema,\n    opts: {useDefaults},\n  } = it\n  if (useDefaults) assignDefaults(it, group.type)\n  gen.block(() => {\n    for (const rule of group.rules) {\n      if (shouldUseRule(schema, rule)) {\n        keywordCode(it, rule.keyword, rule.definition, group.type)\n      }\n    }\n  })\n}\n\nfunction checkStrictTypes(it: SchemaObjCxt, types: JSONType[]): void {\n  if (it.schemaEnv.meta || !it.opts.strictTypes) return\n  checkContextTypes(it, types)\n  if (!it.opts.allowUnionTypes) checkMultipleTypes(it, types)\n  checkKeywordTypes(it, it.dataTypes)\n}\n\nfunction checkContextTypes(it: SchemaObjCxt, types: JSONType[]): void {\n  if (!types.length) return\n  if (!it.dataTypes.length) {\n    it.dataTypes = types\n    return\n  }\n  types.forEach((t) => {\n    if (!includesType(it.dataTypes, t)) {\n      strictTypesError(it, `type \"${t}\" not allowed by context \"${it.dataTypes.join(\",\")}\"`)\n    }\n  })\n  narrowSchemaTypes(it, types)\n}\n\nfunction checkMultipleTypes(it: SchemaObjCxt, ts: JSONType[]): void {\n  if (ts.length > 1 && !(ts.length === 2 && ts.includes(\"null\"))) {\n    strictTypesError(it, \"use allowUnionTypes to allow union type keyword\")\n  }\n}\n\nfunction checkKeywordTypes(it: SchemaObjCxt, ts: JSONType[]): void {\n  const rules = it.self.RULES.all\n  for (const keyword in rules) {\n    const rule = rules[keyword]\n    if (typeof rule == \"object\" && shouldUseRule(it.schema, rule)) {\n      const {type} = rule.definition\n      if (type.length && !type.some((t) => hasApplicableType(ts, t))) {\n        strictTypesError(it, `missing type \"${type.join(\",\")}\" for keyword \"${keyword}\"`)\n      }\n    }\n  }\n}\n\nfunction hasApplicableType(schTs: JSONType[], kwdT: JSONType): boolean {\n  return schTs.includes(kwdT) || (kwdT === \"number\" && schTs.includes(\"integer\"))\n}\n\nfunction includesType(ts: JSONType[], t: JSONType): boolean {\n  return ts.includes(t) || (t === \"integer\" && ts.includes(\"number\"))\n}\n\nfunction narrowSchemaTypes(it: SchemaObjCxt, withTypes: JSONType[]): void {\n  const ts: JSONType[] = []\n  for (const t of it.dataTypes) {\n    if (includesType(withTypes, t)) ts.push(t)\n    else if (withTypes.includes(\"integer\") && t === \"number\") ts.push(\"integer\")\n  }\n  it.dataTypes = ts\n}\n\nfunction strictTypesError(it: SchemaObjCxt, msg: string): void {\n  const schemaPath = it.schemaEnv.baseId + it.errSchemaPath\n  msg += ` at \"${schemaPath}\" (strictTypes)`\n  checkStrictMode(it, msg, it.opts.strictTypes)\n}\n\nexport class KeywordCxt implements KeywordErrorCxt {\n  readonly gen: CodeGen\n  readonly allErrors?: boolean\n  readonly keyword: string\n  readonly data: Name // Name referencing the current level of the data instance\n  readonly $data?: string | false\n  schema: any // keyword value in the schema\n  readonly schemaValue: Code | number | boolean // Code reference to keyword schema value or primitive value\n  readonly schemaCode: Code | number | boolean // Code reference to resolved schema value (different if schema is $data)\n  readonly schemaType: JSONType[] // allowed type(s) of keyword value in the schema\n  readonly parentSchema: AnySchemaObject\n  readonly errsCount?: Name // Name reference to the number of validation errors collected before this keyword,\n  // requires option trackErrors in keyword definition\n  params: KeywordCxtParams // object to pass parameters to error messages from keyword code\n  readonly it: SchemaObjCxt // schema compilation context (schema is guaranteed to be an object, not boolean)\n  readonly def: AddedKeywordDefinition\n\n  constructor(it: SchemaObjCxt, def: AddedKeywordDefinition, keyword: string) {\n    validateKeywordUsage(it, def, keyword)\n    this.gen = it.gen\n    this.allErrors = it.allErrors\n    this.keyword = keyword\n    this.data = it.data\n    this.schema = it.schema[keyword]\n    this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data\n    this.schemaValue = schemaRefOrVal(it, this.schema, keyword, this.$data)\n    this.schemaType = def.schemaType\n    this.parentSchema = it.schema\n    this.params = {}\n    this.it = it\n    this.def = def\n\n    if (this.$data) {\n      this.schemaCode = it.gen.const(\"vSchema\", getData(this.$data, it))\n    } else {\n      this.schemaCode = this.schemaValue\n      if (!validSchemaType(this.schema, def.schemaType, def.allowUndefined)) {\n        throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`)\n      }\n    }\n\n    if (\"code\" in def ? def.trackErrors : def.errors !== false) {\n      this.errsCount = it.gen.const(\"_errs\", N.errors)\n    }\n  }\n\n  result(condition: Code, successAction?: () => void, failAction?: () => void): void {\n    this.failResult(not(condition), successAction, failAction)\n  }\n\n  failResult(condition: Code, successAction?: () => void, failAction?: () => void): void {\n    this.gen.if(condition)\n    if (failAction) failAction()\n    else this.error()\n    if (successAction) {\n      this.gen.else()\n      successAction()\n      if (this.allErrors) this.gen.endIf()\n    } else {\n      if (this.allErrors) this.gen.endIf()\n      else this.gen.else()\n    }\n  }\n\n  pass(condition: Code, failAction?: () => void): void {\n    this.failResult(not(condition), undefined, failAction)\n  }\n\n  fail(condition?: Code): void {\n    if (condition === undefined) {\n      this.error()\n      if (!this.allErrors) this.gen.if(false) // this branch will be removed by gen.optimize\n      return\n    }\n    this.gen.if(condition)\n    this.error()\n    if (this.allErrors) this.gen.endIf()\n    else this.gen.else()\n  }\n\n  fail$data(condition: Code): void {\n    if (!this.$data) return this.fail(condition)\n    const {schemaCode} = this\n    this.fail(_`${schemaCode} !== undefined && (${or(this.invalid$data(), condition)})`)\n  }\n\n  error(append?: boolean, errorParams?: KeywordCxtParams, errorPaths?: ErrorPaths): void {\n    if (errorParams) {\n      this.setParams(errorParams)\n      this._error(append, errorPaths)\n      this.setParams({})\n      return\n    }\n    this._error(append, errorPaths)\n  }\n\n  private _error(append?: boolean, errorPaths?: ErrorPaths): void {\n    ;(append ? reportExtraError : reportError)(this, this.def.error, errorPaths)\n  }\n\n  $dataError(): void {\n    reportError(this, this.def.$dataError || keyword$DataError)\n  }\n\n  reset(): void {\n    if (this.errsCount === undefined) throw new Error('add \"trackErrors\" to keyword definition')\n    resetErrorsCount(this.gen, this.errsCount)\n  }\n\n  ok(cond: Code | boolean): void {\n    if (!this.allErrors) this.gen.if(cond)\n  }\n\n  setParams(obj: KeywordCxtParams, assign?: true): void {\n    if (assign) Object.assign(this.params, obj)\n    else this.params = obj\n  }\n\n  block$data(valid: Name, codeBlock: () => void, $dataValid: Code = nil): void {\n    this.gen.block(() => {\n      this.check$data(valid, $dataValid)\n      codeBlock()\n    })\n  }\n\n  check$data(valid: Name = nil, $dataValid: Code = nil): void {\n    if (!this.$data) return\n    const {gen, schemaCode, schemaType, def} = this\n    gen.if(or(_`${schemaCode} === undefined`, $dataValid))\n    if (valid !== nil) gen.assign(valid, true)\n    if (schemaType.length || def.validateSchema) {\n      gen.elseIf(this.invalid$data())\n      this.$dataError()\n      if (valid !== nil) gen.assign(valid, false)\n    }\n    gen.else()\n  }\n\n  invalid$data(): Code {\n    const {gen, schemaCode, schemaType, def, it} = this\n    return or(wrong$DataType(), invalid$DataSchema())\n\n    function wrong$DataType(): Code {\n      if (schemaType.length) {\n        /* istanbul ignore if */\n        if (!(schemaCode instanceof Name)) throw new Error(\"ajv implementation error\")\n        const st = Array.isArray(schemaType) ? schemaType : [schemaType]\n        return _`${checkDataTypes(st, schemaCode, it.opts.strictNumbers, DataType.Wrong)}`\n      }\n      return nil\n    }\n\n    function invalid$DataSchema(): Code {\n      if (def.validateSchema) {\n        const validateSchemaRef = gen.scopeValue(\"validate$data\", {ref: def.validateSchema}) // TODO value.code for standalone\n        return _`!${validateSchemaRef}(${schemaCode})`\n      }\n      return nil\n    }\n  }\n\n  subschema(appl: SubschemaArgs, valid: Name): SchemaCxt {\n    const subschema = getSubschema(this.it, appl)\n    extendSubschemaData(subschema, this.it, appl)\n    extendSubschemaMode(subschema, appl)\n    const nextContext = {...this.it, ...subschema, items: undefined, props: undefined}\n    subschemaCode(nextContext, valid)\n    return nextContext\n  }\n\n  mergeEvaluated(schemaCxt: SchemaCxt, toName?: typeof Name): void {\n    const {it, gen} = this\n    if (!it.opts.unevaluated) return\n    if (it.props !== true && schemaCxt.props !== undefined) {\n      it.props = mergeEvaluated.props(gen, schemaCxt.props, it.props, toName)\n    }\n    if (it.items !== true && schemaCxt.items !== undefined) {\n      it.items = mergeEvaluated.items(gen, schemaCxt.items, it.items, toName)\n    }\n  }\n\n  mergeValidEvaluated(schemaCxt: SchemaCxt, valid: Name): boolean | void {\n    const {it, gen} = this\n    if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {\n      gen.if(valid, () => this.mergeEvaluated(schemaCxt, Name))\n      return true\n    }\n  }\n}\n\nfunction keywordCode(\n  it: SchemaObjCxt,\n  keyword: string,\n  def: AddedKeywordDefinition,\n  ruleType?: JSONType\n): void {\n  const cxt = new KeywordCxt(it, def, keyword)\n  if (\"code\" in def) {\n    def.code(cxt, ruleType)\n  } else if (cxt.$data && def.validate) {\n    funcKeywordCode(cxt, def)\n  } else if (\"macro\" in def) {\n    macroKeywordCode(cxt, def)\n  } else if (def.compile || def.validate) {\n    funcKeywordCode(cxt, def)\n  }\n}\n\nconst JSON_POINTER = /^\\/(?:[^~]|~0|~1)*$/\nconst RELATIVE_JSON_POINTER = /^([0-9]+)(#|\\/(?:[^~]|~0|~1)*)?$/\nexport function getData(\n  $data: string,\n  {dataLevel, dataNames, dataPathArr}: SchemaCxt\n): Code | number {\n  let jsonPointer\n  let data: Code\n  if ($data === \"\") return N.rootData\n  if ($data[0] === \"/\") {\n    if (!JSON_POINTER.test($data)) throw new Error(`Invalid JSON-pointer: ${$data}`)\n    jsonPointer = $data\n    data = N.rootData\n  } else {\n    const matches = RELATIVE_JSON_POINTER.exec($data)\n    if (!matches) throw new Error(`Invalid JSON-pointer: ${$data}`)\n    const up: number = +matches[1]\n    jsonPointer = matches[2]\n    if (jsonPointer === \"#\") {\n      if (up >= dataLevel) throw new Error(errorMsg(\"property/index\", up))\n      return dataPathArr[dataLevel - up]\n    }\n    if (up > dataLevel) throw new Error(errorMsg(\"data\", up))\n    data = dataNames[dataLevel - up]\n    if (!jsonPointer) return data\n  }\n\n  let expr = data\n  const segments = jsonPointer.split(\"/\")\n  for (const segment of segments) {\n    if (segment) {\n      data = _`${data}${getProperty(unescapeJsonPointer(segment))}`\n      expr = _`${expr} && ${data}`\n    }\n  }\n  return expr\n\n  function errorMsg(pointerType: string, up: number): string {\n    return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`\n  }\n}\n","import type {KeywordCxt} from \".\"\nimport type {\n  AnySchema,\n  SchemaValidateFunction,\n  AnyValidateFunction,\n  AddedKeywordDefinition,\n  MacroKeywordDefinition,\n  FuncKeywordDefinition,\n} from \"../../types\"\nimport type {SchemaObjCxt} from \"..\"\nimport {_, nil, not, stringify, Code, Name, CodeGen} from \"../codegen\"\nimport N from \"../names\"\nimport type {JSONType} from \"../rules\"\nimport {callValidateCode} from \"../../vocabularies/code\"\nimport {extendErrors} from \"../errors\"\n\ntype KeywordCompilationResult = AnySchema | SchemaValidateFunction | AnyValidateFunction\n\nexport function macroKeywordCode(cxt: KeywordCxt, def: MacroKeywordDefinition): void {\n  const {gen, keyword, schema, parentSchema, it} = cxt\n  const macroSchema = def.macro.call(it.self, schema, parentSchema, it)\n  const schemaRef = useKeyword(gen, keyword, macroSchema)\n  if (it.opts.validateSchema !== false) it.self.validateSchema(macroSchema, true)\n\n  const valid = gen.name(\"valid\")\n  cxt.subschema(\n    {\n      schema: macroSchema,\n      schemaPath: nil,\n      errSchemaPath: `${it.errSchemaPath}/${keyword}`,\n      topSchemaRef: schemaRef,\n      compositeRule: true,\n    },\n    valid\n  )\n  cxt.pass(valid, () => cxt.error(true))\n}\n\nexport function funcKeywordCode(cxt: KeywordCxt, def: FuncKeywordDefinition): void {\n  const {gen, keyword, schema, parentSchema, $data, it} = cxt\n  checkAsyncKeyword(it, def)\n  const validate =\n    !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate\n  const validateRef = useKeyword(gen, keyword, validate)\n  const valid = gen.let(\"valid\")\n  cxt.block$data(valid, validateKeyword)\n  cxt.ok(def.valid ?? valid)\n\n  function validateKeyword(): void {\n    if (def.errors === false) {\n      assignValid()\n      if (def.modifying) modifyData(cxt)\n      reportErrs(() => cxt.error())\n    } else {\n      const ruleErrs = def.async ? validateAsync() : validateSync()\n      if (def.modifying) modifyData(cxt)\n      reportErrs(() => addErrs(cxt, ruleErrs))\n    }\n  }\n\n  function validateAsync(): Name {\n    const ruleErrs = gen.let(\"ruleErrs\", null)\n    gen.try(\n      () => assignValid(_`await `),\n      (e) =>\n        gen.assign(valid, false).if(\n          _`${e} instanceof ${it.ValidationError as Name}`,\n          () => gen.assign(ruleErrs, _`${e}.errors`),\n          () => gen.throw(e)\n        )\n    )\n    return ruleErrs\n  }\n\n  function validateSync(): Code {\n    const validateErrs = _`${validateRef}.errors`\n    gen.assign(validateErrs, null)\n    assignValid(nil)\n    return validateErrs\n  }\n\n  function assignValid(_await: Code = def.async ? _`await ` : nil): void {\n    const passCxt = it.opts.passContext ? N.this : N.self\n    const passSchema = !((\"compile\" in def && !$data) || def.schema === false)\n    gen.assign(\n      valid,\n      _`${_await}${callValidateCode(cxt, validateRef, passCxt, passSchema)}`,\n      def.modifying\n    )\n  }\n\n  function reportErrs(errors: () => void): void {\n    gen.if(not(def.valid ?? valid), errors)\n  }\n}\n\nfunction modifyData(cxt: KeywordCxt): void {\n  const {gen, data, it} = cxt\n  gen.if(it.parentData, () => gen.assign(data, _`${it.parentData}[${it.parentDataProperty}]`))\n}\n\nfunction addErrs(cxt: KeywordCxt, errs: Code): void {\n  const {gen} = cxt\n  gen.if(\n    _`Array.isArray(${errs})`,\n    () => {\n      gen\n        .assign(N.vErrors, _`${N.vErrors} === null ? ${errs} : ${N.vErrors}.concat(${errs})`)\n        .assign(N.errors, _`${N.vErrors}.length`)\n      extendErrors(cxt)\n    },\n    () => cxt.error()\n  )\n}\n\nfunction checkAsyncKeyword({schemaEnv}: SchemaObjCxt, def: FuncKeywordDefinition): void {\n  if (def.async && !schemaEnv.$async) throw new Error(\"async keyword in sync schema\")\n}\n\nfunction useKeyword(gen: CodeGen, keyword: string, result?: KeywordCompilationResult): Name {\n  if (result === undefined) throw new Error(`keyword \"${keyword}\" failed to compile`)\n  return gen.scopeValue(\n    \"keyword\",\n    typeof result == \"function\" ? {ref: result} : {ref: result, code: stringify(result)}\n  )\n}\n\nexport function validSchemaType(\n  schema: unknown,\n  schemaType: JSONType[],\n  allowUndefined = false\n): boolean {\n  // TODO add tests\n  return (\n    !schemaType.length ||\n    schemaType.some((st) =>\n      st === \"array\"\n        ? Array.isArray(schema)\n        : st === \"object\"\n        ? schema && typeof schema == \"object\" && !Array.isArray(schema)\n        : typeof schema == st || (allowUndefined && typeof schema == \"undefined\")\n    )\n  )\n}\n\nexport function validateKeywordUsage(\n  {schema, opts, self, errSchemaPath}: SchemaObjCxt,\n  def: AddedKeywordDefinition,\n  keyword: string\n): void {\n  /* istanbul ignore if */\n  if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {\n    throw new Error(\"ajv implementation error\")\n  }\n\n  const deps = def.dependencies\n  if (deps?.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {\n    throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(\",\")}`)\n  }\n\n  if (def.validateSchema) {\n    const valid = def.validateSchema(schema[keyword])\n    if (!valid) {\n      const msg =\n        `keyword \"${keyword}\" value is invalid at path \"${errSchemaPath}\": ` +\n        self.errorsText(def.validateSchema.errors)\n      if (opts.validateSchema === \"log\") self.logger.error(msg)\n      else throw new Error(msg)\n    }\n  }\n}\n","import type {AnySchema} from \"../../types\"\nimport type {SchemaObjCxt} from \"..\"\nimport {_, str, getProperty, Code, Name} from \"../codegen\"\nimport {escapeFragment, getErrorPath, Type} from \"../util\"\nimport type {JSONType} from \"../rules\"\n\nexport interface SubschemaContext {\n  // TODO use Optional? align with SchemCxt property types\n  schema: AnySchema\n  schemaPath: Code\n  errSchemaPath: string\n  topSchemaRef?: Code\n  errorPath?: Code\n  dataLevel?: number\n  dataTypes?: JSONType[]\n  data?: Name\n  parentData?: Name\n  parentDataProperty?: Code | number\n  dataNames?: Name[]\n  dataPathArr?: (Code | number)[]\n  propertyName?: Name\n  jtdDiscriminator?: string\n  jtdMetadata?: boolean\n  compositeRule?: true\n  createErrors?: boolean\n  allErrors?: boolean\n}\n\nexport type SubschemaArgs = Partial<{\n  keyword: string\n  schemaProp: string | number\n  schema: AnySchema\n  schemaPath: Code\n  errSchemaPath: string\n  topSchemaRef: Code\n  data: Name | Code\n  dataProp: Code | string | number\n  dataTypes: JSONType[]\n  definedProperties: Set<string>\n  propertyName: Name\n  dataPropType: Type\n  jtdDiscriminator: string\n  jtdMetadata: boolean\n  compositeRule: true\n  createErrors: boolean\n  allErrors: boolean\n}>\n\nexport function getSubschema(\n  it: SchemaObjCxt,\n  {keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef}: SubschemaArgs\n): SubschemaContext {\n  if (keyword !== undefined && schema !== undefined) {\n    throw new Error('both \"keyword\" and \"schema\" passed, only one allowed')\n  }\n\n  if (keyword !== undefined) {\n    const sch = it.schema[keyword]\n    return schemaProp === undefined\n      ? {\n          schema: sch,\n          schemaPath: _`${it.schemaPath}${getProperty(keyword)}`,\n          errSchemaPath: `${it.errSchemaPath}/${keyword}`,\n        }\n      : {\n          schema: sch[schemaProp],\n          schemaPath: _`${it.schemaPath}${getProperty(keyword)}${getProperty(schemaProp)}`,\n          errSchemaPath: `${it.errSchemaPath}/${keyword}/${escapeFragment(schemaProp)}`,\n        }\n  }\n\n  if (schema !== undefined) {\n    if (schemaPath === undefined || errSchemaPath === undefined || topSchemaRef === undefined) {\n      throw new Error('\"schemaPath\", \"errSchemaPath\" and \"topSchemaRef\" are required with \"schema\"')\n    }\n    return {\n      schema,\n      schemaPath,\n      topSchemaRef,\n      errSchemaPath,\n    }\n  }\n\n  throw new Error('either \"keyword\" or \"schema\" must be passed')\n}\n\nexport function extendSubschemaData(\n  subschema: SubschemaContext,\n  it: SchemaObjCxt,\n  {dataProp, dataPropType: dpType, data, dataTypes, propertyName}: SubschemaArgs\n): void {\n  if (data !== undefined && dataProp !== undefined) {\n    throw new Error('both \"data\" and \"dataProp\" passed, only one allowed')\n  }\n\n  const {gen} = it\n\n  if (dataProp !== undefined) {\n    const {errorPath, dataPathArr, opts} = it\n    const nextData = gen.let(\"data\", _`${it.data}${getProperty(dataProp)}`, true)\n    dataContextProps(nextData)\n    subschema.errorPath = str`${errorPath}${getErrorPath(dataProp, dpType, opts.jsPropertySyntax)}`\n    subschema.parentDataProperty = _`${dataProp}`\n    subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty]\n  }\n\n  if (data !== undefined) {\n    const nextData = data instanceof Name ? data : gen.let(\"data\", data, true) // replaceable if used once?\n    dataContextProps(nextData)\n    if (propertyName !== undefined) subschema.propertyName = propertyName\n    // TODO something is possibly wrong here with not changing parentDataProperty and not appending dataPathArr\n  }\n\n  if (dataTypes) subschema.dataTypes = dataTypes\n\n  function dataContextProps(_nextData: Name): void {\n    subschema.data = _nextData\n    subschema.dataLevel = it.dataLevel + 1\n    subschema.dataTypes = []\n    it.definedProperties = new Set<string>()\n    subschema.parentData = it.data\n    subschema.dataNames = [...it.dataNames, _nextData]\n  }\n}\n\nexport function extendSubschemaMode(\n  subschema: SubschemaContext,\n  {jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors}: SubschemaArgs\n): void {\n  if (compositeRule !== undefined) subschema.compositeRule = compositeRule\n  if (createErrors !== undefined) subschema.createErrors = createErrors\n  if (allErrors !== undefined) subschema.allErrors = allErrors\n  subschema.jtdDiscriminator = jtdDiscriminator // not inherited\n  subschema.jtdMetadata = jtdMetadata // not inherited\n}\n","export {\n  Format,\n  FormatDefinition,\n  AsyncFormatDefinition,\n  KeywordDefinition,\n  KeywordErrorDefinition,\n  CodeKeywordDefinition,\n  MacroKeywordDefinition,\n  FuncKeywordDefinition,\n  Vocabulary,\n  Schema,\n  SchemaObject,\n  AnySchemaObject,\n  AsyncSchema,\n  AnySchema,\n  ValidateFunction,\n  AsyncValidateFunction,\n  AnyValidateFunction,\n  ErrorObject,\n  ErrorNoParams,\n} from \"./types\"\n\nexport {SchemaCxt, SchemaObjCxt} from \"./compile\"\nexport interface Plugin<Opts> {\n  (ajv: Ajv, options?: Opts): Ajv\n  [prop: string]: any\n}\n\nexport {KeywordCxt} from \"./compile/validate\"\nexport {DefinedError} from \"./vocabularies/errors\"\nexport {JSONType} from \"./compile/rules\"\nexport {JSONSchemaType} from \"./types/json-schema\"\nexport {JTDSchemaType, SomeJTDSchemaType, JTDDataType} from \"./types/jtd-schema\"\nexport {_, str, stringify, nil, Name, Code, CodeGen, CodeGenOptions} from \"./compile/codegen\"\n\nimport type {\n  Schema,\n  AnySchema,\n  AnySchemaObject,\n  SchemaObject,\n  AsyncSchema,\n  Vocabulary,\n  KeywordDefinition,\n  AddedKeywordDefinition,\n  AnyValidateFunction,\n  ValidateFunction,\n  AsyncValidateFunction,\n  ErrorObject,\n  Format,\n  AddedFormat,\n  RegExpEngine,\n  UriResolver,\n} from \"./types\"\nimport type {JSONSchemaType} from \"./types/json-schema\"\nimport type {JTDSchemaType, SomeJTDSchemaType, JTDDataType} from \"./types/jtd-schema\"\nimport ValidationError from \"./runtime/validation_error\"\nimport MissingRefError from \"./compile/ref_error\"\nimport {getRules, ValidationRules, Rule, RuleGroup, JSONType} from \"./compile/rules\"\nimport {SchemaEnv, compileSchema, resolveSchema} from \"./compile\"\nimport {Code, ValueScope} from \"./compile/codegen\"\nimport {normalizeId, getSchemaRefs} from \"./compile/resolve\"\nimport {getJSONTypes} from \"./compile/validate/dataType\"\nimport {eachItem} from \"./compile/util\"\nimport * as $dataRefSchema from \"./refs/data.json\"\n\nimport DefaultUriResolver from \"./runtime/uri\"\n\nconst defaultRegExp: RegExpEngine = (str, flags) => new RegExp(str, flags)\ndefaultRegExp.code = \"new RegExp\"\n\nconst META_IGNORE_OPTIONS: (keyof Options)[] = [\"removeAdditional\", \"useDefaults\", \"coerceTypes\"]\nconst EXT_SCOPE_NAMES = new Set([\n  \"validate\",\n  \"serialize\",\n  \"parse\",\n  \"wrapper\",\n  \"root\",\n  \"schema\",\n  \"keyword\",\n  \"pattern\",\n  \"formats\",\n  \"validate$data\",\n  \"func\",\n  \"obj\",\n  \"Error\",\n])\n\nexport type Options = CurrentOptions & DeprecatedOptions\n\nexport interface CurrentOptions {\n  // strict mode options (NEW)\n  strict?: boolean | \"log\"\n  strictSchema?: boolean | \"log\"\n  strictNumbers?: boolean | \"log\"\n  strictTypes?: boolean | \"log\"\n  strictTuples?: boolean | \"log\"\n  strictRequired?: boolean | \"log\"\n  allowMatchingProperties?: boolean // disables a strict mode restriction\n  allowUnionTypes?: boolean\n  validateFormats?: boolean\n  // validation and reporting options:\n  $data?: boolean\n  allErrors?: boolean\n  verbose?: boolean\n  discriminator?: boolean\n  unicodeRegExp?: boolean\n  timestamp?: \"string\" | \"date\" // JTD only\n  parseDate?: boolean // JTD only\n  allowDate?: boolean // JTD only\n  $comment?:\n    | true\n    | ((comment: string, schemaPath?: string, rootSchema?: AnySchemaObject) => unknown)\n  formats?: {[Name in string]?: Format}\n  keywords?: Vocabulary\n  schemas?: AnySchema[] | {[Key in string]?: AnySchema}\n  logger?: Logger | false\n  loadSchema?: (uri: string) => Promise<AnySchemaObject>\n  // options to modify validated data:\n  removeAdditional?: boolean | \"all\" | \"failing\"\n  useDefaults?: boolean | \"empty\"\n  coerceTypes?: boolean | \"array\"\n  // advanced options:\n  next?: boolean // NEW\n  unevaluated?: boolean // NEW\n  dynamicRef?: boolean // NEW\n  schemaId?: \"id\" | \"$id\"\n  jtd?: boolean // NEW\n  meta?: SchemaObject | boolean\n  defaultMeta?: string | AnySchemaObject\n  validateSchema?: boolean | \"log\"\n  addUsedSchema?: boolean\n  inlineRefs?: boolean | number\n  passContext?: boolean\n  loopRequired?: number\n  loopEnum?: number // NEW\n  ownProperties?: boolean\n  multipleOfPrecision?: number\n  int32range?: boolean // JTD only\n  messages?: boolean\n  code?: CodeOptions // NEW\n  uriResolver?: UriResolver\n}\n\nexport interface CodeOptions {\n  es5?: boolean\n  esm?: boolean\n  lines?: boolean\n  optimize?: boolean | number\n  formats?: Code // code to require (or construct) map of available formats - for standalone code\n  source?: boolean\n  process?: (code: string, schema?: SchemaEnv) => string\n  regExp?: RegExpEngine\n}\n\ninterface InstanceCodeOptions extends CodeOptions {\n  regExp: RegExpEngine\n  optimize: number\n}\n\ninterface DeprecatedOptions {\n  /** @deprecated */\n  ignoreKeywordsWithRef?: boolean\n  /** @deprecated */\n  jsPropertySyntax?: boolean // added instead of jsonPointers\n  /** @deprecated */\n  unicode?: boolean\n}\n\ninterface RemovedOptions {\n  format?: boolean\n  errorDataPath?: \"object\" | \"property\"\n  nullable?: boolean // \"nullable\" keyword is supported by default\n  jsonPointers?: boolean\n  extendRefs?: true | \"ignore\" | \"fail\"\n  missingRefs?: true | \"ignore\" | \"fail\"\n  processCode?: (code: string, schema?: SchemaEnv) => string\n  sourceCode?: boolean\n  strictDefaults?: boolean\n  strictKeywords?: boolean\n  uniqueItems?: boolean\n  unknownFormats?: true | string[] | \"ignore\"\n  cache?: any\n  serialize?: (schema: AnySchema) => unknown\n  ajvErrors?: boolean\n}\n\ntype OptionsInfo<T extends RemovedOptions | DeprecatedOptions> = {\n  [K in keyof T]-?: string | undefined\n}\n\nconst removedOptions: OptionsInfo<RemovedOptions> = {\n  errorDataPath: \"\",\n  format: \"`validateFormats: false` can be used instead.\",\n  nullable: '\"nullable\" keyword is supported by default.',\n  jsonPointers: \"Deprecated jsPropertySyntax can be used instead.\",\n  extendRefs: \"Deprecated ignoreKeywordsWithRef can be used instead.\",\n  missingRefs: \"Pass empty schema with $id that should be ignored to ajv.addSchema.\",\n  processCode: \"Use option `code: {process: (code, schemaEnv: object) => string}`\",\n  sourceCode: \"Use option `code: {source: true}`\",\n  strictDefaults: \"It is default now, see option `strict`.\",\n  strictKeywords: \"It is default now, see option `strict`.\",\n  uniqueItems: '\"uniqueItems\" keyword is always validated.',\n  unknownFormats: \"Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).\",\n  cache: \"Map is used as cache, schema object as key.\",\n  serialize: \"Map is used as cache, schema object as key.\",\n  ajvErrors: \"It is default now.\",\n}\n\nconst deprecatedOptions: OptionsInfo<DeprecatedOptions> = {\n  ignoreKeywordsWithRef: \"\",\n  jsPropertySyntax: \"\",\n  unicode: '\"minLength\"/\"maxLength\" account for unicode characters by default.',\n}\n\ntype RequiredInstanceOptions = {\n  [K in\n    | \"strictSchema\"\n    | \"strictNumbers\"\n    | \"strictTypes\"\n    | \"strictTuples\"\n    | \"strictRequired\"\n    | \"inlineRefs\"\n    | \"loopRequired\"\n    | \"loopEnum\"\n    | \"meta\"\n    | \"messages\"\n    | \"schemaId\"\n    | \"addUsedSchema\"\n    | \"validateSchema\"\n    | \"validateFormats\"\n    | \"int32range\"\n    | \"unicodeRegExp\"\n    | \"uriResolver\"]: NonNullable<Options[K]>\n} & {code: InstanceCodeOptions}\n\nexport type InstanceOptions = Options & RequiredInstanceOptions\n\nconst MAX_EXPRESSION = 200\n\n// eslint-disable-next-line complexity\nfunction requiredOptions(o: Options): RequiredInstanceOptions {\n  const s = o.strict\n  const _optz = o.code?.optimize\n  const optimize = _optz === true || _optz === undefined ? 1 : _optz || 0\n  const regExp = o.code?.regExp ?? defaultRegExp\n  const uriResolver = o.uriResolver ?? DefaultUriResolver\n  return {\n    strictSchema: o.strictSchema ?? s ?? true,\n    strictNumbers: o.strictNumbers ?? s ?? true,\n    strictTypes: o.strictTypes ?? s ?? \"log\",\n    strictTuples: o.strictTuples ?? s ?? \"log\",\n    strictRequired: o.strictRequired ?? s ?? false,\n    code: o.code ? {...o.code, optimize, regExp} : {optimize, regExp},\n    loopRequired: o.loopRequired ?? MAX_EXPRESSION,\n    loopEnum: o.loopEnum ?? MAX_EXPRESSION,\n    meta: o.meta ?? true,\n    messages: o.messages ?? true,\n    inlineRefs: o.inlineRefs ?? true,\n    schemaId: o.schemaId ?? \"$id\",\n    addUsedSchema: o.addUsedSchema ?? true,\n    validateSchema: o.validateSchema ?? true,\n    validateFormats: o.validateFormats ?? true,\n    unicodeRegExp: o.unicodeRegExp ?? true,\n    int32range: o.int32range ?? true,\n    uriResolver: uriResolver,\n  }\n}\n\nexport interface Logger {\n  log(...args: unknown[]): unknown\n  warn(...args: unknown[]): unknown\n  error(...args: unknown[]): unknown\n}\n\nexport default class Ajv {\n  opts: InstanceOptions\n  errors?: ErrorObject[] | null // errors from the last validation\n  logger: Logger\n  // shared external scope values for compiled functions\n  readonly scope: ValueScope\n  readonly schemas: {[Key in string]?: SchemaEnv} = {}\n  readonly refs: {[Ref in string]?: SchemaEnv | string} = {}\n  readonly formats: {[Name in string]?: AddedFormat} = {}\n  readonly RULES: ValidationRules\n  readonly _compilations: Set<SchemaEnv> = new Set()\n  private readonly _loading: {[Ref in string]?: Promise<AnySchemaObject>} = {}\n  private readonly _cache: Map<AnySchema, SchemaEnv> = new Map()\n  private readonly _metaOpts: InstanceOptions\n\n  static ValidationError = ValidationError\n  static MissingRefError = MissingRefError\n\n  constructor(opts: Options = {}) {\n    opts = this.opts = {...opts, ...requiredOptions(opts)}\n    const {es5, lines} = this.opts.code\n\n    this.scope = new ValueScope({scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines})\n    this.logger = getLogger(opts.logger)\n    const formatOpt = opts.validateFormats\n    opts.validateFormats = false\n\n    this.RULES = getRules()\n    checkOptions.call(this, removedOptions, opts, \"NOT SUPPORTED\")\n    checkOptions.call(this, deprecatedOptions, opts, \"DEPRECATED\", \"warn\")\n    this._metaOpts = getMetaSchemaOptions.call(this)\n\n    if (opts.formats) addInitialFormats.call(this)\n    this._addVocabularies()\n    this._addDefaultMetaSchema()\n    if (opts.keywords) addInitialKeywords.call(this, opts.keywords)\n    if (typeof opts.meta == \"object\") this.addMetaSchema(opts.meta)\n    addInitialSchemas.call(this)\n    opts.validateFormats = formatOpt\n  }\n\n  _addVocabularies(): void {\n    this.addKeyword(\"$async\")\n  }\n\n  _addDefaultMetaSchema(): void {\n    const {$data, meta, schemaId} = this.opts\n    let _dataRefSchema: SchemaObject = $dataRefSchema\n    if (schemaId === \"id\") {\n      _dataRefSchema = {...$dataRefSchema}\n      _dataRefSchema.id = _dataRefSchema.$id\n      delete _dataRefSchema.$id\n    }\n    if (meta && $data) this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false)\n  }\n\n  defaultMeta(): string | AnySchemaObject | undefined {\n    const {meta, schemaId} = this.opts\n    return (this.opts.defaultMeta = typeof meta == \"object\" ? meta[schemaId] || meta : undefined)\n  }\n\n  // Validate data using schema\n  // AnySchema will be compiled and cached using schema itself as a key for Map\n  validate(schema: Schema | string, data: unknown): boolean\n  validate(schemaKeyRef: AnySchema | string, data: unknown): boolean | Promise<unknown>\n  validate<T>(schema: Schema | JSONSchemaType<T> | string, data: unknown): data is T\n  // Separated for type inference to work\n  // eslint-disable-next-line @typescript-eslint/unified-signatures\n  validate<T>(schema: JTDSchemaType<T>, data: unknown): data is T\n  // This overload is only intended for typescript inference, the first\n  // argument prevents manual type annotation from matching this overload\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  validate<N extends never, T extends SomeJTDSchemaType>(\n    schema: T,\n    data: unknown\n  ): data is JTDDataType<T>\n  // eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\n  validate<T>(schema: AsyncSchema, data: unknown | T): Promise<T>\n  validate<T>(schemaKeyRef: AnySchema | string, data: unknown): data is T | Promise<T>\n  validate<T>(\n    schemaKeyRef: AnySchema | string, // key, ref or schema object\n    // eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\n    data: unknown | T // to be validated\n  ): boolean | Promise<T> {\n    let v: AnyValidateFunction | undefined\n    if (typeof schemaKeyRef == \"string\") {\n      v = this.getSchema<T>(schemaKeyRef)\n      if (!v) throw new Error(`no schema with key or ref \"${schemaKeyRef}\"`)\n    } else {\n      v = this.compile<T>(schemaKeyRef)\n    }\n\n    const valid = v(data)\n    if (!(\"$async\" in v)) this.errors = v.errors\n    return valid\n  }\n\n  // Create validation function for passed schema\n  // _meta: true if schema is a meta-schema. Used internally to compile meta schemas of user-defined keywords.\n  compile<T = unknown>(schema: Schema | JSONSchemaType<T>, _meta?: boolean): ValidateFunction<T>\n  // Separated for type inference to work\n  // eslint-disable-next-line @typescript-eslint/unified-signatures\n  compile<T = unknown>(schema: JTDSchemaType<T>, _meta?: boolean): ValidateFunction<T>\n  // This overload is only intended for typescript inference, the first\n  // argument prevents manual type annotation from matching this overload\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  compile<N extends never, T extends SomeJTDSchemaType>(\n    schema: T,\n    _meta?: boolean\n  ): ValidateFunction<JTDDataType<T>>\n  compile<T = unknown>(schema: AsyncSchema, _meta?: boolean): AsyncValidateFunction<T>\n  compile<T = unknown>(schema: AnySchema, _meta?: boolean): AnyValidateFunction<T>\n  compile<T = unknown>(schema: AnySchema, _meta?: boolean): AnyValidateFunction<T> {\n    const sch = this._addSchema(schema, _meta)\n    return (sch.validate || this._compileSchemaEnv(sch)) as AnyValidateFunction<T>\n  }\n\n  // Creates validating function for passed schema with asynchronous loading of missing schemas.\n  // `loadSchema` option should be a function that accepts schema uri and returns promise that resolves with the schema.\n  // TODO allow passing schema URI\n  // meta - optional true to compile meta-schema\n  compileAsync<T = unknown>(\n    schema: SchemaObject | JSONSchemaType<T>,\n    _meta?: boolean\n  ): Promise<ValidateFunction<T>>\n  // Separated for type inference to work\n  // eslint-disable-next-line @typescript-eslint/unified-signatures\n  compileAsync<T = unknown>(schema: JTDSchemaType<T>, _meta?: boolean): Promise<ValidateFunction<T>>\n  compileAsync<T = unknown>(schema: AsyncSchema, meta?: boolean): Promise<AsyncValidateFunction<T>>\n  // eslint-disable-next-line @typescript-eslint/unified-signatures\n  compileAsync<T = unknown>(\n    schema: AnySchemaObject,\n    meta?: boolean\n  ): Promise<AnyValidateFunction<T>>\n  compileAsync<T = unknown>(\n    schema: AnySchemaObject,\n    meta?: boolean\n  ): Promise<AnyValidateFunction<T>> {\n    if (typeof this.opts.loadSchema != \"function\") {\n      throw new Error(\"options.loadSchema should be a function\")\n    }\n    const {loadSchema} = this.opts\n    return runCompileAsync.call(this, schema, meta)\n\n    async function runCompileAsync(\n      this: Ajv,\n      _schema: AnySchemaObject,\n      _meta?: boolean\n    ): Promise<AnyValidateFunction> {\n      await loadMetaSchema.call(this, _schema.$schema)\n      const sch = this._addSchema(_schema, _meta)\n      return sch.validate || _compileAsync.call(this, sch)\n    }\n\n    async function loadMetaSchema(this: Ajv, $ref?: string): Promise<void> {\n      if ($ref && !this.getSchema($ref)) {\n        await runCompileAsync.call(this, {$ref}, true)\n      }\n    }\n\n    async function _compileAsync(this: Ajv, sch: SchemaEnv): Promise<AnyValidateFunction> {\n      try {\n        return this._compileSchemaEnv(sch)\n      } catch (e) {\n        if (!(e instanceof MissingRefError)) throw e\n        checkLoaded.call(this, e)\n        await loadMissingSchema.call(this, e.missingSchema)\n        return _compileAsync.call(this, sch)\n      }\n    }\n\n    function checkLoaded(this: Ajv, {missingSchema: ref, missingRef}: MissingRefError): void {\n      if (this.refs[ref]) {\n        throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`)\n      }\n    }\n\n    async function loadMissingSchema(this: Ajv, ref: string): Promise<void> {\n      const _schema = await _loadSchema.call(this, ref)\n      if (!this.refs[ref]) await loadMetaSchema.call(this, _schema.$schema)\n      if (!this.refs[ref]) this.addSchema(_schema, ref, meta)\n    }\n\n    async function _loadSchema(this: Ajv, ref: string): Promise<AnySchemaObject> {\n      const p = this._loading[ref]\n      if (p) return p\n      try {\n        return await (this._loading[ref] = loadSchema(ref))\n      } finally {\n        delete this._loading[ref]\n      }\n    }\n  }\n\n  // Adds schema to the instance\n  addSchema(\n    schema: AnySchema | AnySchema[], // If array is passed, `key` will be ignored\n    key?: string, // Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.\n    _meta?: boolean, // true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.\n    _validateSchema = this.opts.validateSchema // false to skip schema validation. Used internally, option validateSchema should be used instead.\n  ): Ajv {\n    if (Array.isArray(schema)) {\n      for (const sch of schema) this.addSchema(sch, undefined, _meta, _validateSchema)\n      return this\n    }\n    let id: string | undefined\n    if (typeof schema === \"object\") {\n      const {schemaId} = this.opts\n      id = schema[schemaId]\n      if (id !== undefined && typeof id != \"string\") {\n        throw new Error(`schema ${schemaId} must be string`)\n      }\n    }\n    key = normalizeId(key || id)\n    this._checkUnique(key)\n    this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true)\n    return this\n  }\n\n  // Add schema that will be used to validate other schemas\n  // options in META_IGNORE_OPTIONS are alway set to false\n  addMetaSchema(\n    schema: AnySchemaObject,\n    key?: string, // schema key\n    _validateSchema = this.opts.validateSchema // false to skip schema validation, can be used to override validateSchema option for meta-schema\n  ): Ajv {\n    this.addSchema(schema, key, true, _validateSchema)\n    return this\n  }\n\n  //  Validate schema against its meta-schema\n  validateSchema(schema: AnySchema, throwOrLogError?: boolean): boolean | Promise<unknown> {\n    if (typeof schema == \"boolean\") return true\n    let $schema: string | AnySchemaObject | undefined\n    $schema = schema.$schema\n    if ($schema !== undefined && typeof $schema != \"string\") {\n      throw new Error(\"$schema must be a string\")\n    }\n    $schema = $schema || this.opts.defaultMeta || this.defaultMeta()\n    if (!$schema) {\n      this.logger.warn(\"meta-schema not available\")\n      this.errors = null\n      return true\n    }\n    const valid = this.validate($schema, schema)\n    if (!valid && throwOrLogError) {\n      const message = \"schema is invalid: \" + this.errorsText()\n      if (this.opts.validateSchema === \"log\") this.logger.error(message)\n      else throw new Error(message)\n    }\n    return valid\n  }\n\n  // Get compiled schema by `key` or `ref`.\n  // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)\n  getSchema<T = unknown>(keyRef: string): AnyValidateFunction<T> | undefined {\n    let sch\n    while (typeof (sch = getSchEnv.call(this, keyRef)) == \"string\") keyRef = sch\n    if (sch === undefined) {\n      const {schemaId} = this.opts\n      const root = new SchemaEnv({schema: {}, schemaId})\n      sch = resolveSchema.call(this, root, keyRef)\n      if (!sch) return\n      this.refs[keyRef] = sch\n    }\n    return (sch.validate || this._compileSchemaEnv(sch)) as AnyValidateFunction<T> | undefined\n  }\n\n  // Remove cached schema(s).\n  // If no parameter is passed all schemas but meta-schemas are removed.\n  // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.\n  // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.\n  removeSchema(schemaKeyRef?: AnySchema | string | RegExp): Ajv {\n    if (schemaKeyRef instanceof RegExp) {\n      this._removeAllSchemas(this.schemas, schemaKeyRef)\n      this._removeAllSchemas(this.refs, schemaKeyRef)\n      return this\n    }\n    switch (typeof schemaKeyRef) {\n      case \"undefined\":\n        this._removeAllSchemas(this.schemas)\n        this._removeAllSchemas(this.refs)\n        this._cache.clear()\n        return this\n      case \"string\": {\n        const sch = getSchEnv.call(this, schemaKeyRef)\n        if (typeof sch == \"object\") this._cache.delete(sch.schema)\n        delete this.schemas[schemaKeyRef]\n        delete this.refs[schemaKeyRef]\n        return this\n      }\n      case \"object\": {\n        const cacheKey = schemaKeyRef\n        this._cache.delete(cacheKey)\n        let id = schemaKeyRef[this.opts.schemaId]\n        if (id) {\n          id = normalizeId(id)\n          delete this.schemas[id]\n          delete this.refs[id]\n        }\n        return this\n      }\n      default:\n        throw new Error(\"ajv.removeSchema: invalid parameter\")\n    }\n  }\n\n  // add \"vocabulary\" - a collection of keywords\n  addVocabulary(definitions: Vocabulary): Ajv {\n    for (const def of definitions) this.addKeyword(def)\n    return this\n  }\n\n  addKeyword(\n    kwdOrDef: string | KeywordDefinition,\n    def?: KeywordDefinition // deprecated\n  ): Ajv {\n    let keyword: string | string[]\n    if (typeof kwdOrDef == \"string\") {\n      keyword = kwdOrDef\n      if (typeof def == \"object\") {\n        this.logger.warn(\"these parameters are deprecated, see docs for addKeyword\")\n        def.keyword = keyword\n      }\n    } else if (typeof kwdOrDef == \"object\" && def === undefined) {\n      def = kwdOrDef\n      keyword = def.keyword\n      if (Array.isArray(keyword) && !keyword.length) {\n        throw new Error(\"addKeywords: keyword must be string or non-empty array\")\n      }\n    } else {\n      throw new Error(\"invalid addKeywords parameters\")\n    }\n\n    checkKeyword.call(this, keyword, def)\n    if (!def) {\n      eachItem(keyword, (kwd) => addRule.call(this, kwd))\n      return this\n    }\n    keywordMetaschema.call(this, def)\n    const definition: AddedKeywordDefinition = {\n      ...def,\n      type: getJSONTypes(def.type),\n      schemaType: getJSONTypes(def.schemaType),\n    }\n    eachItem(\n      keyword,\n      definition.type.length === 0\n        ? (k) => addRule.call(this, k, definition)\n        : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t))\n    )\n    return this\n  }\n\n  getKeyword(keyword: string): AddedKeywordDefinition | boolean {\n    const rule = this.RULES.all[keyword]\n    return typeof rule == \"object\" ? rule.definition : !!rule\n  }\n\n  // Remove keyword\n  removeKeyword(keyword: string): Ajv {\n    // TODO return type should be Ajv\n    const {RULES} = this\n    delete RULES.keywords[keyword]\n    delete RULES.all[keyword]\n    for (const group of RULES.rules) {\n      const i = group.rules.findIndex((rule) => rule.keyword === keyword)\n      if (i >= 0) group.rules.splice(i, 1)\n    }\n    return this\n  }\n\n  // Add format\n  addFormat(name: string, format: Format): Ajv {\n    if (typeof format == \"string\") format = new RegExp(format)\n    this.formats[name] = format\n    return this\n  }\n\n  errorsText(\n    errors: ErrorObject[] | null | undefined = this.errors, // optional array of validation errors\n    {separator = \", \", dataVar = \"data\"}: ErrorsTextOptions = {} // optional options with properties `separator` and `dataVar`\n  ): string {\n    if (!errors || errors.length === 0) return \"No errors\"\n    return errors\n      .map((e) => `${dataVar}${e.instancePath} ${e.message}`)\n      .reduce((text, msg) => text + separator + msg)\n  }\n\n  $dataMetaSchema(metaSchema: AnySchemaObject, keywordsJsonPointers: string[]): AnySchemaObject {\n    const rules = this.RULES.all\n    metaSchema = JSON.parse(JSON.stringify(metaSchema))\n    for (const jsonPointer of keywordsJsonPointers) {\n      const segments = jsonPointer.split(\"/\").slice(1) // first segment is an empty string\n      let keywords = metaSchema\n      for (const seg of segments) keywords = keywords[seg] as AnySchemaObject\n\n      for (const key in rules) {\n        const rule = rules[key]\n        if (typeof rule != \"object\") continue\n        const {$data} = rule.definition\n        const schema = keywords[key] as AnySchemaObject | undefined\n        if ($data && schema) keywords[key] = schemaOrData(schema)\n      }\n    }\n\n    return metaSchema\n  }\n\n  private _removeAllSchemas(schemas: {[Ref in string]?: SchemaEnv | string}, regex?: RegExp): void {\n    for (const keyRef in schemas) {\n      const sch = schemas[keyRef]\n      if (!regex || regex.test(keyRef)) {\n        if (typeof sch == \"string\") {\n          delete schemas[keyRef]\n        } else if (sch && !sch.meta) {\n          this._cache.delete(sch.schema)\n          delete schemas[keyRef]\n        }\n      }\n    }\n  }\n\n  _addSchema(\n    schema: AnySchema,\n    meta?: boolean,\n    baseId?: string,\n    validateSchema = this.opts.validateSchema,\n    addSchema = this.opts.addUsedSchema\n  ): SchemaEnv {\n    let id: string | undefined\n    const {schemaId} = this.opts\n    if (typeof schema == \"object\") {\n      id = schema[schemaId]\n    } else {\n      if (this.opts.jtd) throw new Error(\"schema must be object\")\n      else if (typeof schema != \"boolean\") throw new Error(\"schema must be object or boolean\")\n    }\n    let sch = this._cache.get(schema)\n    if (sch !== undefined) return sch\n\n    baseId = normalizeId(id || baseId)\n    const localRefs = getSchemaRefs.call(this, schema, baseId)\n    sch = new SchemaEnv({schema, schemaId, meta, baseId, localRefs})\n    this._cache.set(sch.schema, sch)\n    if (addSchema && !baseId.startsWith(\"#\")) {\n      // TODO atm it is allowed to overwrite schemas without id (instead of not adding them)\n      if (baseId) this._checkUnique(baseId)\n      this.refs[baseId] = sch\n    }\n    if (validateSchema) this.validateSchema(schema, true)\n    return sch\n  }\n\n  private _checkUnique(id: string): void {\n    if (this.schemas[id] || this.refs[id]) {\n      throw new Error(`schema with key or id \"${id}\" already exists`)\n    }\n  }\n\n  private _compileSchemaEnv(sch: SchemaEnv): AnyValidateFunction {\n    if (sch.meta) this._compileMetaSchema(sch)\n    else compileSchema.call(this, sch)\n\n    /* istanbul ignore if */\n    if (!sch.validate) throw new Error(\"ajv implementation error\")\n    return sch.validate\n  }\n\n  private _compileMetaSchema(sch: SchemaEnv): void {\n    const currentOpts = this.opts\n    this.opts = this._metaOpts\n    try {\n      compileSchema.call(this, sch)\n    } finally {\n      this.opts = currentOpts\n    }\n  }\n}\n\nexport interface ErrorsTextOptions {\n  separator?: string\n  dataVar?: string\n}\n\nfunction checkOptions(\n  this: Ajv,\n  checkOpts: OptionsInfo<RemovedOptions | DeprecatedOptions>,\n  options: Options & RemovedOptions,\n  msg: string,\n  log: \"warn\" | \"error\" = \"error\"\n): void {\n  for (const key in checkOpts) {\n    const opt = key as keyof typeof checkOpts\n    if (opt in options) this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`)\n  }\n}\n\nfunction getSchEnv(this: Ajv, keyRef: string): SchemaEnv | string | undefined {\n  keyRef = normalizeId(keyRef) // TODO tests fail without this line\n  return this.schemas[keyRef] || this.refs[keyRef]\n}\n\nfunction addInitialSchemas(this: Ajv): void {\n  const optsSchemas = this.opts.schemas\n  if (!optsSchemas) return\n  if (Array.isArray(optsSchemas)) this.addSchema(optsSchemas)\n  else for (const key in optsSchemas) this.addSchema(optsSchemas[key] as AnySchema, key)\n}\n\nfunction addInitialFormats(this: Ajv): void {\n  for (const name in this.opts.formats) {\n    const format = this.opts.formats[name]\n    if (format) this.addFormat(name, format)\n  }\n}\n\nfunction addInitialKeywords(\n  this: Ajv,\n  defs: Vocabulary | {[K in string]?: KeywordDefinition}\n): void {\n  if (Array.isArray(defs)) {\n    this.addVocabulary(defs)\n    return\n  }\n  this.logger.warn(\"keywords option as map is deprecated, pass array\")\n  for (const keyword in defs) {\n    const def = defs[keyword] as KeywordDefinition\n    if (!def.keyword) def.keyword = keyword\n    this.addKeyword(def)\n  }\n}\n\nfunction getMetaSchemaOptions(this: Ajv): InstanceOptions {\n  const metaOpts = {...this.opts}\n  for (const opt of META_IGNORE_OPTIONS) delete metaOpts[opt]\n  return metaOpts\n}\n\nconst noLogs = {log() {}, warn() {}, error() {}}\n\nfunction getLogger(logger?: Partial<Logger> | false): Logger {\n  if (logger === false) return noLogs\n  if (logger === undefined) return console\n  if (logger.log && logger.warn && logger.error) return logger as Logger\n  throw new Error(\"logger must implement log, warn and error methods\")\n}\n\nconst KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i\n\nfunction checkKeyword(this: Ajv, keyword: string | string[], def?: KeywordDefinition): void {\n  const {RULES} = this\n  eachItem(keyword, (kwd) => {\n    if (RULES.keywords[kwd]) throw new Error(`Keyword ${kwd} is already defined`)\n    if (!KEYWORD_NAME.test(kwd)) throw new Error(`Keyword ${kwd} has invalid name`)\n  })\n  if (!def) return\n  if (def.$data && !(\"code\" in def || \"validate\" in def)) {\n    throw new Error('$data keyword must have \"code\" or \"validate\" function')\n  }\n}\n\nfunction addRule(\n  this: Ajv,\n  keyword: string,\n  definition?: AddedKeywordDefinition,\n  dataType?: JSONType\n): void {\n  const post = definition?.post\n  if (dataType && post) throw new Error('keyword with \"post\" flag cannot have \"type\"')\n  const {RULES} = this\n  let ruleGroup = post ? RULES.post : RULES.rules.find(({type: t}) => t === dataType)\n  if (!ruleGroup) {\n    ruleGroup = {type: dataType, rules: []}\n    RULES.rules.push(ruleGroup)\n  }\n  RULES.keywords[keyword] = true\n  if (!definition) return\n\n  const rule: Rule = {\n    keyword,\n    definition: {\n      ...definition,\n      type: getJSONTypes(definition.type),\n      schemaType: getJSONTypes(definition.schemaType),\n    },\n  }\n  if (definition.before) addBeforeRule.call(this, ruleGroup, rule, definition.before)\n  else ruleGroup.rules.push(rule)\n  RULES.all[keyword] = rule\n  definition.implements?.forEach((kwd) => this.addKeyword(kwd))\n}\n\nfunction addBeforeRule(this: Ajv, ruleGroup: RuleGroup, rule: Rule, before: string): void {\n  const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before)\n  if (i >= 0) {\n    ruleGroup.rules.splice(i, 0, rule)\n  } else {\n    ruleGroup.rules.push(rule)\n    this.logger.warn(`rule ${before} is not defined`)\n  }\n}\n\nfunction keywordMetaschema(this: Ajv, def: KeywordDefinition): void {\n  let {metaSchema} = def\n  if (metaSchema === undefined) return\n  if (def.$data && this.opts.$data) metaSchema = schemaOrData(metaSchema)\n  def.validateSchema = this.compile(metaSchema, true)\n}\n\nconst $dataRef = {\n  $ref: \"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#\",\n}\n\nfunction schemaOrData(schema: AnySchema): AnySchemaObject {\n  return {anyOf: [schema, $dataRef]}\n}\n","// https://github.com/ajv-validator/ajv/issues/889\nimport * as equal from \"fast-deep-equal\"\n\ntype Equal = typeof equal & {code: string}\n;(equal as Equal).code = 'require(\"ajv/dist/runtime/equal\").default'\n\nexport default equal as Equal\n","// https://mathiasbynens.be/notes/javascript-encoding\n// https://github.com/bestiejs/punycode.js - punycode.ucs2.decode\nexport default function ucs2length(str: string): number {\n  const len = str.length\n  let length = 0\n  let pos = 0\n  let value: number\n  while (pos < len) {\n    length++\n    value = str.charCodeAt(pos++)\n    if (value >= 0xd800 && value <= 0xdbff && pos < len) {\n      // high surrogate, and there is a next character\n      value = str.charCodeAt(pos)\n      if ((value & 0xfc00) === 0xdc00) pos++ // low surrogate\n    }\n  }\n  return length\n}\n\nucs2length.code = 'require(\"ajv/dist/runtime/ucs2length\").default'\n","import * as uri from \"fast-uri\"\n\ntype URI = typeof uri & {code: string}\n;(uri as URI).code = 'require(\"ajv/dist/runtime/uri\").default'\n\nexport default uri as URI\n","import type {ErrorObject} from \"../types\"\n\nexport default class ValidationError extends Error {\n  readonly errors: Partial<ErrorObject>[]\n  readonly ajv: true\n  readonly validation: true\n\n  constructor(errors: Partial<ErrorObject>[]) {\n    super(\"validation failed\")\n    this.errors = errors\n    this.ajv = this.validation = true\n  }\n}\n","import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, not, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema, checkStrictMode, Type} from \"../../compile/util\"\n\nexport type AdditionalItemsError = ErrorObject<\"additionalItems\", {limit: number}, AnySchema>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {len}}) => str`must NOT have more than ${len} items`,\n  params: ({params: {len}}) => _`{limit: ${len}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"additionalItems\" as const,\n  type: \"array\",\n  schemaType: [\"boolean\", \"object\"],\n  before: \"uniqueItems\",\n  error,\n  code(cxt: KeywordCxt) {\n    const {parentSchema, it} = cxt\n    const {items} = parentSchema\n    if (!Array.isArray(items)) {\n      checkStrictMode(it, '\"additionalItems\" is ignored when \"items\" is not an array of schemas')\n      return\n    }\n    validateAdditionalItems(cxt, items)\n  },\n}\n\nexport function validateAdditionalItems(cxt: KeywordCxt, items: AnySchema[]): void {\n  const {gen, schema, data, keyword, it} = cxt\n  it.items = true\n  const len = gen.const(\"len\", _`${data}.length`)\n  if (schema === false) {\n    cxt.setParams({len: items.length})\n    cxt.pass(_`${len} <= ${items.length}`)\n  } else if (typeof schema == \"object\" && !alwaysValidSchema(it, schema)) {\n    const valid = gen.var(\"valid\", _`${len} <= ${items.length}`) // TODO var\n    gen.if(not(valid), () => validateItems(valid))\n    cxt.ok(valid)\n  }\n\n  function validateItems(valid: Name): void {\n    gen.forRange(\"i\", items.length, len, (i) => {\n      cxt.subschema({keyword, dataProp: i, dataPropType: Type.Num}, valid)\n      if (!it.allErrors) gen.if(not(valid), () => gen.break())\n    })\n  }\n}\n\nexport default def\n","import type {\n  CodeKeywordDefinition,\n  AddedKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport {allSchemaProperties, usePattern, isOwnProperty} from \"../code\"\nimport {_, nil, or, not, Code, Name} from \"../../compile/codegen\"\nimport N from \"../../compile/names\"\nimport type {SubschemaArgs} from \"../../compile/validate/subschema\"\nimport {alwaysValidSchema, schemaRefOrVal, Type} from \"../../compile/util\"\n\nexport type AdditionalPropertiesError = ErrorObject<\n  \"additionalProperties\",\n  {additionalProperty: string},\n  AnySchema\n>\n\nconst error: KeywordErrorDefinition = {\n  message: \"must NOT have additional properties\",\n  params: ({params}) => _`{additionalProperty: ${params.additionalProperty}}`,\n}\n\nconst def: CodeKeywordDefinition & AddedKeywordDefinition = {\n  keyword: \"additionalProperties\",\n  type: [\"object\"],\n  schemaType: [\"boolean\", \"object\"],\n  allowUndefined: true,\n  trackErrors: true,\n  error,\n  code(cxt) {\n    const {gen, schema, parentSchema, data, errsCount, it} = cxt\n    /* istanbul ignore if */\n    if (!errsCount) throw new Error(\"ajv implementation error\")\n    const {allErrors, opts} = it\n    it.props = true\n    if (opts.removeAdditional !== \"all\" && alwaysValidSchema(it, schema)) return\n    const props = allSchemaProperties(parentSchema.properties)\n    const patProps = allSchemaProperties(parentSchema.patternProperties)\n    checkAdditionalProperties()\n    cxt.ok(_`${errsCount} === ${N.errors}`)\n\n    function checkAdditionalProperties(): void {\n      gen.forIn(\"key\", data, (key: Name) => {\n        if (!props.length && !patProps.length) additionalPropertyCode(key)\n        else gen.if(isAdditional(key), () => additionalPropertyCode(key))\n      })\n    }\n\n    function isAdditional(key: Name): Code {\n      let definedProp: Code\n      if (props.length > 8) {\n        // TODO maybe an option instead of hard-coded 8?\n        const propsSchema = schemaRefOrVal(it, parentSchema.properties, \"properties\")\n        definedProp = isOwnProperty(gen, propsSchema as Code, key)\n      } else if (props.length) {\n        definedProp = or(...props.map((p) => _`${key} === ${p}`))\n      } else {\n        definedProp = nil\n      }\n      if (patProps.length) {\n        definedProp = or(definedProp, ...patProps.map((p) => _`${usePattern(cxt, p)}.test(${key})`))\n      }\n      return not(definedProp)\n    }\n\n    function deleteAdditional(key: Name): void {\n      gen.code(_`delete ${data}[${key}]`)\n    }\n\n    function additionalPropertyCode(key: Name): void {\n      if (opts.removeAdditional === \"all\" || (opts.removeAdditional && schema === false)) {\n        deleteAdditional(key)\n        return\n      }\n\n      if (schema === false) {\n        cxt.setParams({additionalProperty: key})\n        cxt.error()\n        if (!allErrors) gen.break()\n        return\n      }\n\n      if (typeof schema == \"object\" && !alwaysValidSchema(it, schema)) {\n        const valid = gen.name(\"valid\")\n        if (opts.removeAdditional === \"failing\") {\n          applyAdditionalSchema(key, valid, false)\n          gen.if(not(valid), () => {\n            cxt.reset()\n            deleteAdditional(key)\n          })\n        } else {\n          applyAdditionalSchema(key, valid)\n          if (!allErrors) gen.if(not(valid), () => gen.break())\n        }\n      }\n    }\n\n    function applyAdditionalSchema(key: Name, valid: Name, errors?: false): void {\n      const subschema: SubschemaArgs = {\n        keyword: \"additionalProperties\",\n        dataProp: key,\n        dataPropType: Type.Str,\n      }\n      if (errors === false) {\n        Object.assign(subschema, {\n          compositeRule: true,\n          createErrors: false,\n          allErrors: false,\n        })\n      }\n      cxt.subschema(subschema, valid)\n    }\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, AnySchema} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {alwaysValidSchema} from \"../../compile/util\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"allOf\",\n  schemaType: \"array\",\n  code(cxt: KeywordCxt) {\n    const {gen, schema, it} = cxt\n    /* istanbul ignore if */\n    if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\")\n    const valid = gen.name(\"valid\")\n    schema.forEach((sch: AnySchema, i: number) => {\n      if (alwaysValidSchema(it, sch)) return\n      const schCxt = cxt.subschema({keyword: \"allOf\", schemaProp: i}, valid)\n      cxt.ok(valid)\n      cxt.mergeEvaluated(schCxt)\n    })\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, ErrorNoParams, AnySchema} from \"../../types\"\nimport {validateUnion} from \"../code\"\n\nexport type AnyOfError = ErrorNoParams<\"anyOf\", AnySchema[]>\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"anyOf\",\n  schemaType: \"array\",\n  trackErrors: true,\n  code: validateUnion,\n  error: {message: \"must match a schema in anyOf\"},\n}\n\nexport default def\n","import type {\n  CodeKeywordDefinition,\n  KeywordErrorDefinition,\n  ErrorObject,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema, checkStrictMode, Type} from \"../../compile/util\"\n\nexport type ContainsError = ErrorObject<\n  \"contains\",\n  {minContains: number; maxContains?: number},\n  AnySchema\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {min, max}}) =>\n    max === undefined\n      ? str`must contain at least ${min} valid item(s)`\n      : str`must contain at least ${min} and no more than ${max} valid item(s)`,\n  params: ({params: {min, max}}) =>\n    max === undefined ? _`{minContains: ${min}}` : _`{minContains: ${min}, maxContains: ${max}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"contains\",\n  type: \"array\",\n  schemaType: [\"object\", \"boolean\"],\n  before: \"uniqueItems\",\n  trackErrors: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, parentSchema, data, it} = cxt\n    let min: number\n    let max: number | undefined\n    const {minContains, maxContains} = parentSchema\n    if (it.opts.next) {\n      min = minContains === undefined ? 1 : minContains\n      max = maxContains\n    } else {\n      min = 1\n    }\n    const len = gen.const(\"len\", _`${data}.length`)\n    cxt.setParams({min, max})\n    if (max === undefined && min === 0) {\n      checkStrictMode(it, `\"minContains\" == 0 without \"maxContains\": \"contains\" keyword ignored`)\n      return\n    }\n    if (max !== undefined && min > max) {\n      checkStrictMode(it, `\"minContains\" > \"maxContains\" is always invalid`)\n      cxt.fail()\n      return\n    }\n    if (alwaysValidSchema(it, schema)) {\n      let cond = _`${len} >= ${min}`\n      if (max !== undefined) cond = _`${cond} && ${len} <= ${max}`\n      cxt.pass(cond)\n      return\n    }\n\n    it.items = true\n    const valid = gen.name(\"valid\")\n    if (max === undefined && min === 1) {\n      validateItems(valid, () => gen.if(valid, () => gen.break()))\n    } else if (min === 0) {\n      gen.let(valid, true)\n      if (max !== undefined) gen.if(_`${data}.length > 0`, validateItemsWithCount)\n    } else {\n      gen.let(valid, false)\n      validateItemsWithCount()\n    }\n    cxt.result(valid, () => cxt.reset())\n\n    function validateItemsWithCount(): void {\n      const schValid = gen.name(\"_valid\")\n      const count = gen.let(\"count\", 0)\n      validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)))\n    }\n\n    function validateItems(_valid: Name, block: () => void): void {\n      gen.forRange(\"i\", 0, len, (i) => {\n        cxt.subschema(\n          {\n            keyword: \"contains\",\n            dataProp: i,\n            dataPropType: Type.Num,\n            compositeRule: true,\n          },\n          _valid\n        )\n        block()\n      })\n    }\n\n    function checkLimits(count: Name): void {\n      gen.code(_`${count}++`)\n      if (max === undefined) {\n        gen.if(_`${count} >= ${min}`, () => gen.assign(valid, true).break())\n      } else {\n        gen.if(_`${count} > ${max}`, () => gen.assign(valid, false).break())\n        if (min === 1) gen.assign(valid, true)\n        else gen.if(_`${count} >= ${min}`, () => gen.assign(valid, true))\n      }\n    }\n  },\n}\n\nexport default def\n","import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  SchemaMap,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str} from \"../../compile/codegen\"\nimport {alwaysValidSchema} from \"../../compile/util\"\nimport {checkReportMissingProp, checkMissingProp, reportMissingProp, propertyInData} from \"../code\"\n\nexport type PropertyDependencies = {[K in string]?: string[]}\n\nexport interface DependenciesErrorParams {\n  property: string\n  missingProperty: string\n  depsCount: number\n  deps: string // TODO change to string[]\n}\n\ntype SchemaDependencies = SchemaMap\n\nexport type DependenciesError = ErrorObject<\n  \"dependencies\",\n  DependenciesErrorParams,\n  {[K in string]?: string[] | AnySchema}\n>\n\nexport const error: KeywordErrorDefinition = {\n  message: ({params: {property, depsCount, deps}}) => {\n    const property_ies = depsCount === 1 ? \"property\" : \"properties\"\n    return str`must have ${property_ies} ${deps} when property ${property} is present`\n  },\n  params: ({params: {property, depsCount, deps, missingProperty}}) =>\n    _`{property: ${property},\n    missingProperty: ${missingProperty},\n    depsCount: ${depsCount},\n    deps: ${deps}}`, // TODO change to reference\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"dependencies\",\n  type: \"object\",\n  schemaType: \"object\",\n  error,\n  code(cxt: KeywordCxt) {\n    const [propDeps, schDeps] = splitDependencies(cxt)\n    validatePropertyDeps(cxt, propDeps)\n    validateSchemaDeps(cxt, schDeps)\n  },\n}\n\nfunction splitDependencies({schema}: KeywordCxt): [PropertyDependencies, SchemaDependencies] {\n  const propertyDeps: PropertyDependencies = {}\n  const schemaDeps: SchemaDependencies = {}\n  for (const key in schema) {\n    if (key === \"__proto__\") continue\n    const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps\n    deps[key] = schema[key]\n  }\n  return [propertyDeps, schemaDeps]\n}\n\nexport function validatePropertyDeps(\n  cxt: KeywordCxt,\n  propertyDeps: {[K in string]?: string[]} = cxt.schema\n): void {\n  const {gen, data, it} = cxt\n  if (Object.keys(propertyDeps).length === 0) return\n  const missing = gen.let(\"missing\")\n  for (const prop in propertyDeps) {\n    const deps = propertyDeps[prop] as string[]\n    if (deps.length === 0) continue\n    const hasProperty = propertyInData(gen, data, prop, it.opts.ownProperties)\n    cxt.setParams({\n      property: prop,\n      depsCount: deps.length,\n      deps: deps.join(\", \"),\n    })\n    if (it.allErrors) {\n      gen.if(hasProperty, () => {\n        for (const depProp of deps) {\n          checkReportMissingProp(cxt, depProp)\n        }\n      })\n    } else {\n      gen.if(_`${hasProperty} && (${checkMissingProp(cxt, deps, missing)})`)\n      reportMissingProp(cxt, missing)\n      gen.else()\n    }\n  }\n}\n\nexport function validateSchemaDeps(cxt: KeywordCxt, schemaDeps: SchemaMap = cxt.schema): void {\n  const {gen, data, keyword, it} = cxt\n  const valid = gen.name(\"valid\")\n  for (const prop in schemaDeps) {\n    if (alwaysValidSchema(it, schemaDeps[prop] as AnySchema)) continue\n    gen.if(\n      propertyInData(gen, data, prop, it.opts.ownProperties),\n      () => {\n        const schCxt = cxt.subschema({keyword, schemaProp: prop}, valid)\n        cxt.mergeValidEvaluated(schCxt, valid)\n      },\n      () => gen.var(valid, true) // TODO var\n    )\n    cxt.ok(valid)\n  }\n}\n\nexport default def\n","import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport type {SchemaObjCxt} from \"../../compile\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, not, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema, checkStrictMode} from \"../../compile/util\"\n\nexport type IfKeywordError = ErrorObject<\"if\", {failingKeyword: string}, AnySchema>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params}) => str`must match \"${params.ifClause}\" schema`,\n  params: ({params}) => _`{failingKeyword: ${params.ifClause}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"if\",\n  schemaType: [\"object\", \"boolean\"],\n  trackErrors: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, parentSchema, it} = cxt\n    if (parentSchema.then === undefined && parentSchema.else === undefined) {\n      checkStrictMode(it, '\"if\" without \"then\" and \"else\" is ignored')\n    }\n    const hasThen = hasSchema(it, \"then\")\n    const hasElse = hasSchema(it, \"else\")\n    if (!hasThen && !hasElse) return\n\n    const valid = gen.let(\"valid\", true)\n    const schValid = gen.name(\"_valid\")\n    validateIf()\n    cxt.reset()\n\n    if (hasThen && hasElse) {\n      const ifClause = gen.let(\"ifClause\")\n      cxt.setParams({ifClause})\n      gen.if(schValid, validateClause(\"then\", ifClause), validateClause(\"else\", ifClause))\n    } else if (hasThen) {\n      gen.if(schValid, validateClause(\"then\"))\n    } else {\n      gen.if(not(schValid), validateClause(\"else\"))\n    }\n\n    cxt.pass(valid, () => cxt.error(true))\n\n    function validateIf(): void {\n      const schCxt = cxt.subschema(\n        {\n          keyword: \"if\",\n          compositeRule: true,\n          createErrors: false,\n          allErrors: false,\n        },\n        schValid\n      )\n      cxt.mergeEvaluated(schCxt)\n    }\n\n    function validateClause(keyword: string, ifClause?: Name): () => void {\n      return () => {\n        const schCxt = cxt.subschema({keyword}, schValid)\n        gen.assign(valid, schValid)\n        cxt.mergeValidEvaluated(schCxt, valid)\n        if (ifClause) gen.assign(ifClause, _`${keyword}`)\n        else cxt.setParams({ifClause: keyword})\n      }\n    }\n  },\n}\n\nfunction hasSchema(it: SchemaObjCxt, keyword: string): boolean {\n  const schema = it.schema[keyword]\n  return schema !== undefined && !alwaysValidSchema(it, schema)\n}\n\nexport default def\n","import type {ErrorNoParams, Vocabulary} from \"../../types\"\nimport additionalItems, {AdditionalItemsError} from \"./additionalItems\"\nimport prefixItems from \"./prefixItems\"\nimport items from \"./items\"\nimport items2020, {ItemsError} from \"./items2020\"\nimport contains, {ContainsError} from \"./contains\"\nimport dependencies, {DependenciesError} from \"./dependencies\"\nimport propertyNames, {PropertyNamesError} from \"./propertyNames\"\nimport additionalProperties, {AdditionalPropertiesError} from \"./additionalProperties\"\nimport properties from \"./properties\"\nimport patternProperties from \"./patternProperties\"\nimport notKeyword, {NotKeywordError} from \"./not\"\nimport anyOf, {AnyOfError} from \"./anyOf\"\nimport oneOf, {OneOfError} from \"./oneOf\"\nimport allOf from \"./allOf\"\nimport ifKeyword, {IfKeywordError} from \"./if\"\nimport thenElse from \"./thenElse\"\n\nexport default function getApplicator(draft2020 = false): Vocabulary {\n  const applicator = [\n    // any\n    notKeyword,\n    anyOf,\n    oneOf,\n    allOf,\n    ifKeyword,\n    thenElse,\n    // object\n    propertyNames,\n    additionalProperties,\n    dependencies,\n    properties,\n    patternProperties,\n  ]\n  // array\n  if (draft2020) applicator.push(prefixItems, items2020)\n  else applicator.push(additionalItems, items)\n  applicator.push(contains)\n  return applicator\n}\n\nexport type ApplicatorKeywordError =\n  | ErrorNoParams<\"false schema\">\n  | AdditionalItemsError\n  | ItemsError\n  | ContainsError\n  | AdditionalPropertiesError\n  | DependenciesError\n  | IfKeywordError\n  | AnyOfError\n  | OneOfError\n  | NotKeywordError\n  | PropertyNamesError\n","import type {CodeKeywordDefinition, AnySchema, AnySchemaObject} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_} from \"../../compile/codegen\"\nimport {alwaysValidSchema, mergeEvaluated, checkStrictMode} from \"../../compile/util\"\nimport {validateArray} from \"../code\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"items\",\n  type: \"array\",\n  schemaType: [\"object\", \"array\", \"boolean\"],\n  before: \"uniqueItems\",\n  code(cxt: KeywordCxt) {\n    const {schema, it} = cxt\n    if (Array.isArray(schema)) return validateTuple(cxt, \"additionalItems\", schema)\n    it.items = true\n    if (alwaysValidSchema(it, schema)) return\n    cxt.ok(validateArray(cxt))\n  },\n}\n\nexport function validateTuple(\n  cxt: KeywordCxt,\n  extraItems: string,\n  schArr: AnySchema[] = cxt.schema\n): void {\n  const {gen, parentSchema, data, keyword, it} = cxt\n  checkStrictTuple(parentSchema)\n  if (it.opts.unevaluated && schArr.length && it.items !== true) {\n    it.items = mergeEvaluated.items(gen, schArr.length, it.items)\n  }\n  const valid = gen.name(\"valid\")\n  const len = gen.const(\"len\", _`${data}.length`)\n  schArr.forEach((sch: AnySchema, i: number) => {\n    if (alwaysValidSchema(it, sch)) return\n    gen.if(_`${len} > ${i}`, () =>\n      cxt.subschema(\n        {\n          keyword,\n          schemaProp: i,\n          dataProp: i,\n        },\n        valid\n      )\n    )\n    cxt.ok(valid)\n  })\n\n  function checkStrictTuple(sch: AnySchemaObject): void {\n    const {opts, errSchemaPath} = it\n    const l = schArr.length\n    const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false)\n    if (opts.strictTuples && !fullTuple) {\n      const msg = `\"${keyword}\" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path \"${errSchemaPath}\"`\n      checkStrictMode(it, msg, opts.strictTuples)\n    }\n  }\n}\n\nexport default def\n","import type {\n  CodeKeywordDefinition,\n  KeywordErrorDefinition,\n  ErrorObject,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str} from \"../../compile/codegen\"\nimport {alwaysValidSchema} from \"../../compile/util\"\nimport {validateArray} from \"../code\"\nimport {validateAdditionalItems} from \"./additionalItems\"\n\nexport type ItemsError = ErrorObject<\"items\", {limit: number}, AnySchema>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {len}}) => str`must NOT have more than ${len} items`,\n  params: ({params: {len}}) => _`{limit: ${len}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"items\",\n  type: \"array\",\n  schemaType: [\"object\", \"boolean\"],\n  before: \"uniqueItems\",\n  error,\n  code(cxt: KeywordCxt) {\n    const {schema, parentSchema, it} = cxt\n    const {prefixItems} = parentSchema\n    it.items = true\n    if (alwaysValidSchema(it, schema)) return\n    if (prefixItems) validateAdditionalItems(cxt, prefixItems)\n    else cxt.ok(validateArray(cxt))\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, ErrorNoParams, AnySchema} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {alwaysValidSchema} from \"../../compile/util\"\n\nexport type NotKeywordError = ErrorNoParams<\"not\", AnySchema>\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"not\",\n  schemaType: [\"object\", \"boolean\"],\n  trackErrors: true,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, it} = cxt\n    if (alwaysValidSchema(it, schema)) {\n      cxt.fail()\n      return\n    }\n\n    const valid = gen.name(\"valid\")\n    cxt.subschema(\n      {\n        keyword: \"not\",\n        compositeRule: true,\n        createErrors: false,\n        allErrors: false,\n      },\n      valid\n    )\n\n    cxt.failResult(\n      valid,\n      () => cxt.reset(),\n      () => cxt.error()\n    )\n  },\n  error: {message: \"must NOT be valid\"},\n}\n\nexport default def\n","import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema} from \"../../compile/util\"\nimport {SchemaCxt} from \"../../compile\"\n\nexport type OneOfError = ErrorObject<\n  \"oneOf\",\n  {passingSchemas: [number, number] | null},\n  AnySchema[]\n>\n\nconst error: KeywordErrorDefinition = {\n  message: \"must match exactly one schema in oneOf\",\n  params: ({params}) => _`{passingSchemas: ${params.passing}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"oneOf\",\n  schemaType: \"array\",\n  trackErrors: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, parentSchema, it} = cxt\n    /* istanbul ignore if */\n    if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\")\n    if (it.opts.discriminator && parentSchema.discriminator) return\n    const schArr: AnySchema[] = schema\n    const valid = gen.let(\"valid\", false)\n    const passing = gen.let(\"passing\", null)\n    const schValid = gen.name(\"_valid\")\n    cxt.setParams({passing})\n    // TODO possibly fail straight away (with warning or exception) if there are two empty always valid schemas\n\n    gen.block(validateOneOf)\n\n    cxt.result(\n      valid,\n      () => cxt.reset(),\n      () => cxt.error(true)\n    )\n\n    function validateOneOf(): void {\n      schArr.forEach((sch: AnySchema, i: number) => {\n        let schCxt: SchemaCxt | undefined\n        if (alwaysValidSchema(it, sch)) {\n          gen.var(schValid, true)\n        } else {\n          schCxt = cxt.subschema(\n            {\n              keyword: \"oneOf\",\n              schemaProp: i,\n              compositeRule: true,\n            },\n            schValid\n          )\n        }\n\n        if (i > 0) {\n          gen\n            .if(_`${schValid} && ${valid}`)\n            .assign(valid, false)\n            .assign(passing, _`[${passing}, ${i}]`)\n            .else()\n        }\n\n        gen.if(schValid, () => {\n          gen.assign(valid, true)\n          gen.assign(passing, i)\n          if (schCxt) cxt.mergeEvaluated(schCxt, Name)\n        })\n      })\n    }\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {allSchemaProperties, usePattern} from \"../code\"\nimport {_, not, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema, checkStrictMode} from \"../../compile/util\"\nimport {evaluatedPropsToName, Type} from \"../../compile/util\"\nimport {AnySchema} from \"../../types\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"patternProperties\",\n  type: \"object\",\n  schemaType: \"object\",\n  code(cxt: KeywordCxt) {\n    const {gen, schema, data, parentSchema, it} = cxt\n    const {opts} = it\n    const patterns = allSchemaProperties(schema)\n    const alwaysValidPatterns = patterns.filter((p) =>\n      alwaysValidSchema(it, schema[p] as AnySchema)\n    )\n\n    if (\n      patterns.length === 0 ||\n      (alwaysValidPatterns.length === patterns.length &&\n        (!it.opts.unevaluated || it.props === true))\n    ) {\n      return\n    }\n\n    const checkProperties =\n      opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties\n    const valid = gen.name(\"valid\")\n    if (it.props !== true && !(it.props instanceof Name)) {\n      it.props = evaluatedPropsToName(gen, it.props)\n    }\n    const {props} = it\n    validatePatternProperties()\n\n    function validatePatternProperties(): void {\n      for (const pat of patterns) {\n        if (checkProperties) checkMatchingProperties(pat)\n        if (it.allErrors) {\n          validateProperties(pat)\n        } else {\n          gen.var(valid, true) // TODO var\n          validateProperties(pat)\n          gen.if(valid)\n        }\n      }\n    }\n\n    function checkMatchingProperties(pat: string): void {\n      for (const prop in checkProperties) {\n        if (new RegExp(pat).test(prop)) {\n          checkStrictMode(\n            it,\n            `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`\n          )\n        }\n      }\n    }\n\n    function validateProperties(pat: string): void {\n      gen.forIn(\"key\", data, (key) => {\n        gen.if(_`${usePattern(cxt, pat)}.test(${key})`, () => {\n          const alwaysValid = alwaysValidPatterns.includes(pat)\n          if (!alwaysValid) {\n            cxt.subschema(\n              {\n                keyword: \"patternProperties\",\n                schemaProp: pat,\n                dataProp: key,\n                dataPropType: Type.Str,\n              },\n              valid\n            )\n          }\n\n          if (it.opts.unevaluated && props !== true) {\n            gen.assign(_`${props}[${key}]`, true)\n          } else if (!alwaysValid && !it.allErrors) {\n            // can short-circuit if `unevaluatedProperties` is not supported (opts.next === false)\n            // or if all properties were evaluated (props === true)\n            gen.if(not(valid), () => gen.break())\n          }\n        })\n      })\n    }\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition} from \"../../types\"\nimport {validateTuple} from \"./items\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"prefixItems\",\n  type: \"array\",\n  schemaType: [\"array\"],\n  before: \"uniqueItems\",\n  code: (cxt) => validateTuple(cxt, \"items\"),\n}\n\nexport default def\n","import type {CodeKeywordDefinition} from \"../../types\"\nimport {KeywordCxt} from \"../../compile/validate\"\nimport {propertyInData, allSchemaProperties} from \"../code\"\nimport {alwaysValidSchema, toHash, mergeEvaluated} from \"../../compile/util\"\nimport apDef from \"./additionalProperties\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"properties\",\n  type: \"object\",\n  schemaType: \"object\",\n  code(cxt: KeywordCxt) {\n    const {gen, schema, parentSchema, data, it} = cxt\n    if (it.opts.removeAdditional === \"all\" && parentSchema.additionalProperties === undefined) {\n      apDef.code(new KeywordCxt(it, apDef, \"additionalProperties\"))\n    }\n    const allProps = allSchemaProperties(schema)\n    for (const prop of allProps) {\n      it.definedProperties.add(prop)\n    }\n    if (it.opts.unevaluated && allProps.length && it.props !== true) {\n      it.props = mergeEvaluated.props(gen, toHash(allProps), it.props)\n    }\n    const properties = allProps.filter((p) => !alwaysValidSchema(it, schema[p]))\n    if (properties.length === 0) return\n    const valid = gen.name(\"valid\")\n\n    for (const prop of properties) {\n      if (hasDefault(prop)) {\n        applyPropertySchema(prop)\n      } else {\n        gen.if(propertyInData(gen, data, prop, it.opts.ownProperties))\n        applyPropertySchema(prop)\n        if (!it.allErrors) gen.else().var(valid, true)\n        gen.endIf()\n      }\n      cxt.it.definedProperties.add(prop)\n      cxt.ok(valid)\n    }\n\n    function hasDefault(prop: string): boolean | undefined {\n      return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== undefined\n    }\n\n    function applyPropertySchema(prop: string): void {\n      cxt.subschema(\n        {\n          keyword: \"properties\",\n          schemaProp: prop,\n          dataProp: prop,\n        },\n        valid\n      )\n    }\n  },\n}\n\nexport default def\n","import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, not} from \"../../compile/codegen\"\nimport {alwaysValidSchema} from \"../../compile/util\"\n\nexport type PropertyNamesError = ErrorObject<\"propertyNames\", {propertyName: string}, AnySchema>\n\nconst error: KeywordErrorDefinition = {\n  message: \"property name must be valid\",\n  params: ({params}) => _`{propertyName: ${params.propertyName}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"propertyNames\",\n  type: \"object\",\n  schemaType: [\"object\", \"boolean\"],\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, data, it} = cxt\n    if (alwaysValidSchema(it, schema)) return\n    const valid = gen.name(\"valid\")\n\n    gen.forIn(\"key\", data, (key) => {\n      cxt.setParams({propertyName: key})\n      cxt.subschema(\n        {\n          keyword: \"propertyNames\",\n          data: key,\n          dataTypes: [\"string\"],\n          propertyName: key,\n          compositeRule: true,\n        },\n        valid\n      )\n      gen.if(not(valid), () => {\n        cxt.error(true)\n        if (!it.allErrors) gen.break()\n      })\n    })\n\n    cxt.ok(valid)\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {checkStrictMode} from \"../../compile/util\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: [\"then\", \"else\"],\n  schemaType: [\"object\", \"boolean\"],\n  code({keyword, parentSchema, it}: KeywordCxt) {\n    if (parentSchema.if === undefined) checkStrictMode(it, `\"${keyword}\" without \"if\" is ignored`)\n  },\n}\n\nexport default def\n","import type {AnySchema, SchemaMap} from \"../types\"\nimport type {SchemaCxt} from \"../compile\"\nimport type {KeywordCxt} from \"../compile/validate\"\nimport {CodeGen, _, and, or, not, nil, strConcat, getProperty, Code, Name} from \"../compile/codegen\"\nimport {alwaysValidSchema, Type} from \"../compile/util\"\nimport N from \"../compile/names\"\nimport {useFunc} from \"../compile/util\"\nexport function checkReportMissingProp(cxt: KeywordCxt, prop: string): void {\n  const {gen, data, it} = cxt\n  gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {\n    cxt.setParams({missingProperty: _`${prop}`}, true)\n    cxt.error()\n  })\n}\n\nexport function checkMissingProp(\n  {gen, data, it: {opts}}: KeywordCxt,\n  properties: string[],\n  missing: Name\n): Code {\n  return or(\n    ...properties.map((prop) =>\n      and(noPropertyInData(gen, data, prop, opts.ownProperties), _`${missing} = ${prop}`)\n    )\n  )\n}\n\nexport function reportMissingProp(cxt: KeywordCxt, missing: Name): void {\n  cxt.setParams({missingProperty: missing}, true)\n  cxt.error()\n}\n\nexport function hasPropFunc(gen: CodeGen): Name {\n  return gen.scopeValue(\"func\", {\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    ref: Object.prototype.hasOwnProperty,\n    code: _`Object.prototype.hasOwnProperty`,\n  })\n}\n\nexport function isOwnProperty(gen: CodeGen, data: Name, property: Name | string): Code {\n  return _`${hasPropFunc(gen)}.call(${data}, ${property})`\n}\n\nexport function propertyInData(\n  gen: CodeGen,\n  data: Name,\n  property: Name | string,\n  ownProperties?: boolean\n): Code {\n  const cond = _`${data}${getProperty(property)} !== undefined`\n  return ownProperties ? _`${cond} && ${isOwnProperty(gen, data, property)}` : cond\n}\n\nexport function noPropertyInData(\n  gen: CodeGen,\n  data: Name,\n  property: Name | string,\n  ownProperties?: boolean\n): Code {\n  const cond = _`${data}${getProperty(property)} === undefined`\n  return ownProperties ? or(cond, not(isOwnProperty(gen, data, property))) : cond\n}\n\nexport function allSchemaProperties(schemaMap?: SchemaMap): string[] {\n  return schemaMap ? Object.keys(schemaMap).filter((p) => p !== \"__proto__\") : []\n}\n\nexport function schemaProperties(it: SchemaCxt, schemaMap: SchemaMap): string[] {\n  return allSchemaProperties(schemaMap).filter(\n    (p) => !alwaysValidSchema(it, schemaMap[p] as AnySchema)\n  )\n}\n\nexport function callValidateCode(\n  {schemaCode, data, it: {gen, topSchemaRef, schemaPath, errorPath}, it}: KeywordCxt,\n  func: Code,\n  context: Code,\n  passSchema?: boolean\n): Code {\n  const dataAndSchema = passSchema ? _`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data\n  const valCxt: [Name, Code | number][] = [\n    [N.instancePath, strConcat(N.instancePath, errorPath)],\n    [N.parentData, it.parentData],\n    [N.parentDataProperty, it.parentDataProperty],\n    [N.rootData, N.rootData],\n  ]\n  if (it.opts.dynamicRef) valCxt.push([N.dynamicAnchors, N.dynamicAnchors])\n  const args = _`${dataAndSchema}, ${gen.object(...valCxt)}`\n  return context !== nil ? _`${func}.call(${context}, ${args})` : _`${func}(${args})`\n}\n\nconst newRegExp = _`new RegExp`\n\nexport function usePattern({gen, it: {opts}}: KeywordCxt, pattern: string): Name {\n  const u = opts.unicodeRegExp ? \"u\" : \"\"\n  const {regExp} = opts.code\n  const rx = regExp(pattern, u)\n\n  return gen.scopeValue(\"pattern\", {\n    key: rx.toString(),\n    ref: rx,\n    code: _`${regExp.code === \"new RegExp\" ? newRegExp : useFunc(gen, regExp)}(${pattern}, ${u})`,\n  })\n}\n\nexport function validateArray(cxt: KeywordCxt): Name {\n  const {gen, data, keyword, it} = cxt\n  const valid = gen.name(\"valid\")\n  if (it.allErrors) {\n    const validArr = gen.let(\"valid\", true)\n    validateItems(() => gen.assign(validArr, false))\n    return validArr\n  }\n  gen.var(valid, true)\n  validateItems(() => gen.break())\n  return valid\n\n  function validateItems(notValid: () => void): void {\n    const len = gen.const(\"len\", _`${data}.length`)\n    gen.forRange(\"i\", 0, len, (i) => {\n      cxt.subschema(\n        {\n          keyword,\n          dataProp: i,\n          dataPropType: Type.Num,\n        },\n        valid\n      )\n      gen.if(not(valid), notValid)\n    })\n  }\n}\n\nexport function validateUnion(cxt: KeywordCxt): void {\n  const {gen, schema, keyword, it} = cxt\n  /* istanbul ignore if */\n  if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\")\n  const alwaysValid = schema.some((sch: AnySchema) => alwaysValidSchema(it, sch))\n  if (alwaysValid && !it.opts.unevaluated) return\n\n  const valid = gen.let(\"valid\", false)\n  const schValid = gen.name(\"_valid\")\n\n  gen.block(() =>\n    schema.forEach((_sch: AnySchema, i: number) => {\n      const schCxt = cxt.subschema(\n        {\n          keyword,\n          schemaProp: i,\n          compositeRule: true,\n        },\n        schValid\n      )\n      gen.assign(valid, _`${valid} || ${schValid}`)\n      const merged = cxt.mergeValidEvaluated(schCxt, schValid)\n      // can short-circuit if `unevaluatedProperties/Items` not supported (opts.unevaluated !== true)\n      // or if all properties and items were evaluated (it.props === true && it.items === true)\n      if (!merged) gen.if(not(valid))\n    })\n  )\n\n  cxt.result(\n    valid,\n    () => cxt.reset(),\n    () => cxt.error(true)\n  )\n}\n","import type {CodeKeywordDefinition} from \"../../types\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"id\",\n  code() {\n    throw new Error('NOT SUPPORTED: keyword \"id\", use \"$id\" for schema ID')\n  },\n}\n\nexport default def\n","import type {Vocabulary} from \"../../types\"\nimport idKeyword from \"./id\"\nimport refKeyword from \"./ref\"\n\nconst core: Vocabulary = [\n  \"$schema\",\n  \"$id\",\n  \"$defs\",\n  \"$vocabulary\",\n  {keyword: \"$comment\"},\n  \"definitions\",\n  idKeyword,\n  refKeyword,\n]\n\nexport default core\n","import type {CodeKeywordDefinition, AnySchema} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport MissingRefError from \"../../compile/ref_error\"\nimport {callValidateCode} from \"../code\"\nimport {_, nil, stringify, Code, Name} from \"../../compile/codegen\"\nimport N from \"../../compile/names\"\nimport {SchemaEnv, resolveRef} from \"../../compile\"\nimport {mergeEvaluated} from \"../../compile/util\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"$ref\",\n  schemaType: \"string\",\n  code(cxt: KeywordCxt): void {\n    const {gen, schema: $ref, it} = cxt\n    const {baseId, schemaEnv: env, validateName, opts, self} = it\n    const {root} = env\n    if (($ref === \"#\" || $ref === \"#/\") && baseId === root.baseId) return callRootRef()\n    const schOrEnv = resolveRef.call(self, root, baseId, $ref)\n    if (schOrEnv === undefined) throw new MissingRefError(it.opts.uriResolver, baseId, $ref)\n    if (schOrEnv instanceof SchemaEnv) return callValidate(schOrEnv)\n    return inlineRefSchema(schOrEnv)\n\n    function callRootRef(): void {\n      if (env === root) return callRef(cxt, validateName, env, env.$async)\n      const rootName = gen.scopeValue(\"root\", {ref: root})\n      return callRef(cxt, _`${rootName}.validate`, root, root.$async)\n    }\n\n    function callValidate(sch: SchemaEnv): void {\n      const v = getValidate(cxt, sch)\n      callRef(cxt, v, sch, sch.$async)\n    }\n\n    function inlineRefSchema(sch: AnySchema): void {\n      const schName = gen.scopeValue(\n        \"schema\",\n        opts.code.source === true ? {ref: sch, code: stringify(sch)} : {ref: sch}\n      )\n      const valid = gen.name(\"valid\")\n      const schCxt = cxt.subschema(\n        {\n          schema: sch,\n          dataTypes: [],\n          schemaPath: nil,\n          topSchemaRef: schName,\n          errSchemaPath: $ref,\n        },\n        valid\n      )\n      cxt.mergeEvaluated(schCxt)\n      cxt.ok(valid)\n    }\n  },\n}\n\nexport function getValidate(cxt: KeywordCxt, sch: SchemaEnv): Code {\n  const {gen} = cxt\n  return sch.validate\n    ? gen.scopeValue(\"validate\", {ref: sch.validate})\n    : _`${gen.scopeValue(\"wrapper\", {ref: sch})}.validate`\n}\n\nexport function callRef(cxt: KeywordCxt, v: Code, sch?: SchemaEnv, $async?: boolean): void {\n  const {gen, it} = cxt\n  const {allErrors, schemaEnv: env, opts} = it\n  const passCxt = opts.passContext ? N.this : nil\n  if ($async) callAsyncRef()\n  else callSyncRef()\n\n  function callAsyncRef(): void {\n    if (!env.$async) throw new Error(\"async schema referenced by sync schema\")\n    const valid = gen.let(\"valid\")\n    gen.try(\n      () => {\n        gen.code(_`await ${callValidateCode(cxt, v, passCxt)}`)\n        addEvaluatedFrom(v) // TODO will not work with async, it has to be returned with the result\n        if (!allErrors) gen.assign(valid, true)\n      },\n      (e) => {\n        gen.if(_`!(${e} instanceof ${it.ValidationError as Name})`, () => gen.throw(e))\n        addErrorsFrom(e)\n        if (!allErrors) gen.assign(valid, false)\n      }\n    )\n    cxt.ok(valid)\n  }\n\n  function callSyncRef(): void {\n    cxt.result(\n      callValidateCode(cxt, v, passCxt),\n      () => addEvaluatedFrom(v),\n      () => addErrorsFrom(v)\n    )\n  }\n\n  function addErrorsFrom(source: Code): void {\n    const errs = _`${source}.errors`\n    gen.assign(N.vErrors, _`${N.vErrors} === null ? ${errs} : ${N.vErrors}.concat(${errs})`) // TODO tagged\n    gen.assign(N.errors, _`${N.vErrors}.length`)\n  }\n\n  function addEvaluatedFrom(source: Code): void {\n    if (!it.opts.unevaluated) return\n    const schEvaluated = sch?.validate?.evaluated\n    // TODO refactor\n    if (it.props !== true) {\n      if (schEvaluated && !schEvaluated.dynamicProps) {\n        if (schEvaluated.props !== undefined) {\n          it.props = mergeEvaluated.props(gen, schEvaluated.props, it.props)\n        }\n      } else {\n        const props = gen.var(\"props\", _`${source}.evaluated.props`)\n        it.props = mergeEvaluated.props(gen, props, it.props, Name)\n      }\n    }\n    if (it.items !== true) {\n      if (schEvaluated && !schEvaluated.dynamicItems) {\n        if (schEvaluated.items !== undefined) {\n          it.items = mergeEvaluated.items(gen, schEvaluated.items, it.items)\n        }\n      } else {\n        const items = gen.var(\"items\", _`${source}.evaluated.items`)\n        it.items = mergeEvaluated.items(gen, items, it.items, Name)\n      }\n    }\n  }\n}\n\nexport default def\n","import type {CodeKeywordDefinition, AnySchemaObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, getProperty, Name} from \"../../compile/codegen\"\nimport {DiscrError, DiscrErrorObj} from \"../discriminator/types\"\nimport {resolveRef, SchemaEnv} from \"../../compile\"\nimport MissingRefError from \"../../compile/ref_error\"\nimport {schemaHasRulesButRef} from \"../../compile/util\"\n\nexport type DiscriminatorError = DiscrErrorObj<DiscrError.Tag> | DiscrErrorObj<DiscrError.Mapping>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {discrError, tagName}}) =>\n    discrError === DiscrError.Tag\n      ? `tag \"${tagName}\" must be string`\n      : `value of tag \"${tagName}\" must be in oneOf`,\n  params: ({params: {discrError, tag, tagName}}) =>\n    _`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"discriminator\",\n  type: \"object\",\n  schemaType: \"object\",\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, schema, parentSchema, it} = cxt\n    const {oneOf} = parentSchema\n    if (!it.opts.discriminator) {\n      throw new Error(\"discriminator: requires discriminator option\")\n    }\n    const tagName = schema.propertyName\n    if (typeof tagName != \"string\") throw new Error(\"discriminator: requires propertyName\")\n    if (schema.mapping) throw new Error(\"discriminator: mapping is not supported\")\n    if (!oneOf) throw new Error(\"discriminator: requires oneOf keyword\")\n    const valid = gen.let(\"valid\", false)\n    const tag = gen.const(\"tag\", _`${data}${getProperty(tagName)}`)\n    gen.if(\n      _`typeof ${tag} == \"string\"`,\n      () => validateMapping(),\n      () => cxt.error(false, {discrError: DiscrError.Tag, tag, tagName})\n    )\n    cxt.ok(valid)\n\n    function validateMapping(): void {\n      const mapping = getMapping()\n      gen.if(false)\n      for (const tagValue in mapping) {\n        gen.elseIf(_`${tag} === ${tagValue}`)\n        gen.assign(valid, applyTagSchema(mapping[tagValue]))\n      }\n      gen.else()\n      cxt.error(false, {discrError: DiscrError.Mapping, tag, tagName})\n      gen.endIf()\n    }\n\n    function applyTagSchema(schemaProp?: number): Name {\n      const _valid = gen.name(\"valid\")\n      const schCxt = cxt.subschema({keyword: \"oneOf\", schemaProp}, _valid)\n      cxt.mergeEvaluated(schCxt, Name)\n      return _valid\n    }\n\n    function getMapping(): {[T in string]?: number} {\n      const oneOfMapping: {[T in string]?: number} = {}\n      const topRequired = hasRequired(parentSchema)\n      let tagRequired = true\n      for (let i = 0; i < oneOf.length; i++) {\n        let sch = oneOf[i]\n        if (sch?.$ref && !schemaHasRulesButRef(sch, it.self.RULES)) {\n          const ref = sch.$ref\n          sch = resolveRef.call(it.self, it.schemaEnv.root, it.baseId, ref)\n          if (sch instanceof SchemaEnv) sch = sch.schema\n          if (sch === undefined) throw new MissingRefError(it.opts.uriResolver, it.baseId, ref)\n        }\n        const propSch = sch?.properties?.[tagName]\n        if (typeof propSch != \"object\") {\n          throw new Error(\n            `discriminator: oneOf subschemas (or referenced schemas) must have \"properties/${tagName}\"`\n          )\n        }\n        tagRequired = tagRequired && (topRequired || hasRequired(sch))\n        addMappings(propSch, i)\n      }\n      if (!tagRequired) throw new Error(`discriminator: \"${tagName}\" must be required`)\n      return oneOfMapping\n\n      function hasRequired({required}: AnySchemaObject): boolean {\n        return Array.isArray(required) && required.includes(tagName)\n      }\n\n      function addMappings(sch: AnySchemaObject, i: number): void {\n        if (sch.const) {\n          addMapping(sch.const, i)\n        } else if (sch.enum) {\n          for (const tagValue of sch.enum) {\n            addMapping(tagValue, i)\n          }\n        } else {\n          throw new Error(`discriminator: \"properties/${tagName}\" must have \"const\" or \"enum\"`)\n        }\n      }\n\n      function addMapping(tagValue: unknown, i: number): void {\n        if (typeof tagValue != \"string\" || tagValue in oneOfMapping) {\n          throw new Error(`discriminator: \"${tagName}\" values must be unique strings`)\n        }\n        oneOfMapping[tagValue] = i\n      }\n    }\n  },\n}\n\nexport default def\n","import type {ErrorObject} from \"../../types\"\n\nexport enum DiscrError {\n  Tag = \"tag\",\n  Mapping = \"mapping\",\n}\n\nexport type DiscrErrorObj<E extends DiscrError> = ErrorObject<\n  \"discriminator\",\n  {error: E; tag: string; tagValue: unknown},\n  string\n>\n","import type {Vocabulary} from \"../types\"\nimport coreVocabulary from \"./core\"\nimport validationVocabulary from \"./validation\"\nimport getApplicatorVocabulary from \"./applicator\"\nimport formatVocabulary from \"./format\"\nimport {metadataVocabulary, contentVocabulary} from \"./metadata\"\n\nconst draft7Vocabularies: Vocabulary[] = [\n  coreVocabulary,\n  validationVocabulary,\n  getApplicatorVocabulary(),\n  formatVocabulary,\n  metadataVocabulary,\n  contentVocabulary,\n]\n\nexport default draft7Vocabularies\n","import type {\n  AddedFormat,\n  FormatValidator,\n  AsyncFormatValidator,\n  CodeKeywordDefinition,\n  KeywordErrorDefinition,\n  ErrorObject,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, nil, or, Code, getProperty, regexpCode} from \"../../compile/codegen\"\n\ntype FormatValidate =\n  | FormatValidator<string>\n  | FormatValidator<number>\n  | AsyncFormatValidator<string>\n  | AsyncFormatValidator<number>\n  | RegExp\n  | string\n  | true\n\nexport type FormatError = ErrorObject<\"format\", {format: string}, string | {$data: string}>\n\nconst error: KeywordErrorDefinition = {\n  message: ({schemaCode}) => str`must match format \"${schemaCode}\"`,\n  params: ({schemaCode}) => _`{format: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"format\",\n  type: [\"number\", \"string\"],\n  schemaType: \"string\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt, ruleType?: string) {\n    const {gen, data, $data, schema, schemaCode, it} = cxt\n    const {opts, errSchemaPath, schemaEnv, self} = it\n    if (!opts.validateFormats) return\n\n    if ($data) validate$DataFormat()\n    else validateFormat()\n\n    function validate$DataFormat(): void {\n      const fmts = gen.scopeValue(\"formats\", {\n        ref: self.formats,\n        code: opts.code.formats,\n      })\n      const fDef = gen.const(\"fDef\", _`${fmts}[${schemaCode}]`)\n      const fType = gen.let(\"fType\")\n      const format = gen.let(\"format\")\n      // TODO simplify\n      gen.if(\n        _`typeof ${fDef} == \"object\" && !(${fDef} instanceof RegExp)`,\n        () => gen.assign(fType, _`${fDef}.type || \"string\"`).assign(format, _`${fDef}.validate`),\n        () => gen.assign(fType, _`\"string\"`).assign(format, fDef)\n      )\n      cxt.fail$data(or(unknownFmt(), invalidFmt()))\n\n      function unknownFmt(): Code {\n        if (opts.strictSchema === false) return nil\n        return _`${schemaCode} && !${format}`\n      }\n\n      function invalidFmt(): Code {\n        const callFormat = schemaEnv.$async\n          ? _`(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))`\n          : _`${format}(${data})`\n        const validData = _`(typeof ${format} == \"function\" ? ${callFormat} : ${format}.test(${data}))`\n        return _`${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`\n      }\n    }\n\n    function validateFormat(): void {\n      const formatDef: AddedFormat | undefined = self.formats[schema]\n      if (!formatDef) {\n        unknownFormat()\n        return\n      }\n      if (formatDef === true) return\n      const [fmtType, format, fmtRef] = getFormat(formatDef)\n      if (fmtType === ruleType) cxt.pass(validCondition())\n\n      function unknownFormat(): void {\n        if (opts.strictSchema === false) {\n          self.logger.warn(unknownMsg())\n          return\n        }\n        throw new Error(unknownMsg())\n\n        function unknownMsg(): string {\n          return `unknown format \"${schema as string}\" ignored in schema at path \"${errSchemaPath}\"`\n        }\n      }\n\n      function getFormat(fmtDef: AddedFormat): [string, FormatValidate, Code] {\n        const code =\n          fmtDef instanceof RegExp\n            ? regexpCode(fmtDef)\n            : opts.code.formats\n            ? _`${opts.code.formats}${getProperty(schema)}`\n            : undefined\n        const fmt = gen.scopeValue(\"formats\", {key: schema, ref: fmtDef, code})\n        if (typeof fmtDef == \"object\" && !(fmtDef instanceof RegExp)) {\n          return [fmtDef.type || \"string\", fmtDef.validate, _`${fmt}.validate`]\n        }\n\n        return [\"string\", fmtDef, fmt]\n      }\n\n      function validCondition(): Code {\n        if (typeof formatDef == \"object\" && !(formatDef instanceof RegExp) && formatDef.async) {\n          if (!schemaEnv.$async) throw new Error(\"async format in sync schema\")\n          return _`await ${fmtRef}(${data})`\n        }\n        return typeof format == \"function\" ? _`${fmtRef}(${data})` : _`${fmtRef}.test(${data})`\n      }\n    }\n  },\n}\n\nexport default def\n","import type {Vocabulary} from \"../../types\"\nimport formatKeyword from \"./format\"\n\nconst format: Vocabulary = [formatKeyword]\n\nexport default format\n","import type {Vocabulary} from \"../types\"\n\nexport const metadataVocabulary: Vocabulary = [\n  \"title\",\n  \"description\",\n  \"default\",\n  \"deprecated\",\n  \"readOnly\",\n  \"writeOnly\",\n  \"examples\",\n]\n\nexport const contentVocabulary: Vocabulary = [\n  \"contentMediaType\",\n  \"contentEncoding\",\n  \"contentSchema\",\n]\n","import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_} from \"../../compile/codegen\"\nimport {useFunc} from \"../../compile/util\"\nimport equal from \"../../runtime/equal\"\n\nexport type ConstError = ErrorObject<\"const\", {allowedValue: any}>\n\nconst error: KeywordErrorDefinition = {\n  message: \"must be equal to constant\",\n  params: ({schemaCode}) => _`{allowedValue: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"const\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, $data, schemaCode, schema} = cxt\n    if ($data || (schema && typeof schema == \"object\")) {\n      cxt.fail$data(_`!${useFunc(gen, equal)}(${data}, ${schemaCode})`)\n    } else {\n      cxt.fail(_`${schema} !== ${data}`)\n    }\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, or, Name, Code} from \"../../compile/codegen\"\nimport {useFunc} from \"../../compile/util\"\nimport equal from \"../../runtime/equal\"\n\nexport type EnumError = ErrorObject<\"enum\", {allowedValues: any[]}, any[] | {$data: string}>\n\nconst error: KeywordErrorDefinition = {\n  message: \"must be equal to one of the allowed values\",\n  params: ({schemaCode}) => _`{allowedValues: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"enum\",\n  schemaType: \"array\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, $data, schema, schemaCode, it} = cxt\n    if (!$data && schema.length === 0) throw new Error(\"enum must have non-empty array\")\n    const useLoop = schema.length >= it.opts.loopEnum\n    let eql: Name | undefined\n    const getEql = (): Name => (eql ??= useFunc(gen, equal))\n\n    let valid: Code\n    if (useLoop || $data) {\n      valid = gen.let(\"valid\")\n      cxt.block$data(valid, loopEnum)\n    } else {\n      /* istanbul ignore if */\n      if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\")\n      const vSchema = gen.const(\"vSchema\", schemaCode)\n      valid = or(...schema.map((_x: unknown, i: number) => equalCode(vSchema, i)))\n    }\n    cxt.pass(valid)\n\n    function loopEnum(): void {\n      gen.assign(valid, false)\n      gen.forOf(\"v\", schemaCode as Code, (v) =>\n        gen.if(_`${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break())\n      )\n    }\n\n    function equalCode(vSchema: Name, i: number): Code {\n      const sch = schema[i]\n      return typeof sch === \"object\" && sch !== null\n        ? _`${getEql()}(${data}, ${vSchema}[${i}])`\n        : _`${data} === ${sch}`\n    }\n  },\n}\n\nexport default def\n","import type {ErrorObject, Vocabulary} from \"../../types\"\nimport limitNumber, {LimitNumberError} from \"./limitNumber\"\nimport multipleOf, {MultipleOfError} from \"./multipleOf\"\nimport limitLength from \"./limitLength\"\nimport pattern, {PatternError} from \"./pattern\"\nimport limitProperties from \"./limitProperties\"\nimport required, {RequiredError} from \"./required\"\nimport limitItems from \"./limitItems\"\nimport uniqueItems, {UniqueItemsError} from \"./uniqueItems\"\nimport constKeyword, {ConstError} from \"./const\"\nimport enumKeyword, {EnumError} from \"./enum\"\n\nconst validation: Vocabulary = [\n  // number\n  limitNumber,\n  multipleOf,\n  // string\n  limitLength,\n  pattern,\n  // object\n  limitProperties,\n  required,\n  // array\n  limitItems,\n  uniqueItems,\n  // any\n  {keyword: \"type\", schemaType: [\"string\", \"array\"]},\n  {keyword: \"nullable\", schemaType: \"boolean\"},\n  constKeyword,\n  enumKeyword,\n]\n\nexport default validation\n\ntype LimitError = ErrorObject<\n  \"maxItems\" | \"minItems\" | \"minProperties\" | \"maxProperties\" | \"minLength\" | \"maxLength\",\n  {limit: number},\n  number | {$data: string}\n>\n\nexport type ValidationKeywordError =\n  | LimitError\n  | LimitNumberError\n  | MultipleOfError\n  | PatternError\n  | RequiredError\n  | UniqueItemsError\n  | ConstError\n  | EnumError\n","import type {CodeKeywordDefinition, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, operators} from \"../../compile/codegen\"\n\nconst error: KeywordErrorDefinition = {\n  message({keyword, schemaCode}) {\n    const comp = keyword === \"maxItems\" ? \"more\" : \"fewer\"\n    return str`must NOT have ${comp} than ${schemaCode} items`\n  },\n  params: ({schemaCode}) => _`{limit: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: [\"maxItems\", \"minItems\"],\n  type: \"array\",\n  schemaType: \"number\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {keyword, data, schemaCode} = cxt\n    const op = keyword === \"maxItems\" ? operators.GT : operators.LT\n    cxt.fail$data(_`${data}.length ${op} ${schemaCode}`)\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, operators} from \"../../compile/codegen\"\nimport {useFunc} from \"../../compile/util\"\nimport ucs2length from \"../../runtime/ucs2length\"\n\nconst error: KeywordErrorDefinition = {\n  message({keyword, schemaCode}) {\n    const comp = keyword === \"maxLength\" ? \"more\" : \"fewer\"\n    return str`must NOT have ${comp} than ${schemaCode} characters`\n  },\n  params: ({schemaCode}) => _`{limit: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: [\"maxLength\", \"minLength\"],\n  type: \"string\",\n  schemaType: \"number\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {keyword, data, schemaCode, it} = cxt\n    const op = keyword === \"maxLength\" ? operators.GT : operators.LT\n    const len =\n      it.opts.unicode === false ? _`${data}.length` : _`${useFunc(cxt.gen, ucs2length)}(${data})`\n    cxt.fail$data(_`${len} ${op} ${schemaCode}`)\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, operators, Code} from \"../../compile/codegen\"\n\nconst ops = operators\n\ntype Kwd = \"maximum\" | \"minimum\" | \"exclusiveMaximum\" | \"exclusiveMinimum\"\n\ntype Comparison = \"<=\" | \">=\" | \"<\" | \">\"\n\nconst KWDs: {[K in Kwd]: {okStr: Comparison; ok: Code; fail: Code}} = {\n  maximum: {okStr: \"<=\", ok: ops.LTE, fail: ops.GT},\n  minimum: {okStr: \">=\", ok: ops.GTE, fail: ops.LT},\n  exclusiveMaximum: {okStr: \"<\", ok: ops.LT, fail: ops.GTE},\n  exclusiveMinimum: {okStr: \">\", ok: ops.GT, fail: ops.LTE},\n}\n\nexport type LimitNumberError = ErrorObject<\n  Kwd,\n  {limit: number; comparison: Comparison},\n  number | {$data: string}\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({keyword, schemaCode}) => str`must be ${KWDs[keyword as Kwd].okStr} ${schemaCode}`,\n  params: ({keyword, schemaCode}) =>\n    _`{comparison: ${KWDs[keyword as Kwd].okStr}, limit: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: Object.keys(KWDs),\n  type: \"number\",\n  schemaType: \"number\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {keyword, data, schemaCode} = cxt\n    cxt.fail$data(_`${data} ${KWDs[keyword as Kwd].fail} ${schemaCode} || isNaN(${data})`)\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, operators} from \"../../compile/codegen\"\n\nconst error: KeywordErrorDefinition = {\n  message({keyword, schemaCode}) {\n    const comp = keyword === \"maxProperties\" ? \"more\" : \"fewer\"\n    return str`must NOT have ${comp} than ${schemaCode} properties`\n  },\n  params: ({schemaCode}) => _`{limit: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: [\"maxProperties\", \"minProperties\"],\n  type: \"object\",\n  schemaType: \"number\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {keyword, data, schemaCode} = cxt\n    const op = keyword === \"maxProperties\" ? operators.GT : operators.LT\n    cxt.fail$data(_`Object.keys(${data}).length ${op} ${schemaCode}`)\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str} from \"../../compile/codegen\"\n\nexport type MultipleOfError = ErrorObject<\n  \"multipleOf\",\n  {multipleOf: number},\n  number | {$data: string}\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({schemaCode}) => str`must be multiple of ${schemaCode}`,\n  params: ({schemaCode}) => _`{multipleOf: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"multipleOf\",\n  type: \"number\",\n  schemaType: \"number\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, schemaCode, it} = cxt\n    // const bdt = bad$DataType(schemaCode, <string>def.schemaType, $data)\n    const prec = it.opts.multipleOfPrecision\n    const res = gen.let(\"res\")\n    const invalid = prec\n      ? _`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}`\n      : _`${res} !== parseInt(${res})`\n    cxt.fail$data(_`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`)\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {usePattern} from \"../code\"\nimport {_, str} from \"../../compile/codegen\"\n\nexport type PatternError = ErrorObject<\"pattern\", {pattern: string}, string | {$data: string}>\n\nconst error: KeywordErrorDefinition = {\n  message: ({schemaCode}) => str`must match pattern \"${schemaCode}\"`,\n  params: ({schemaCode}) => _`{pattern: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"pattern\",\n  type: \"string\",\n  schemaType: \"string\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {data, $data, schema, schemaCode, it} = cxt\n    // TODO regexp should be wrapped in try/catchs\n    const u = it.opts.unicodeRegExp ? \"u\" : \"\"\n    const regExp = $data ? _`(new RegExp(${schemaCode}, ${u}))` : usePattern(cxt, schema)\n    cxt.fail$data(_`!${regExp}.test(${data})`)\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {\n  checkReportMissingProp,\n  checkMissingProp,\n  reportMissingProp,\n  propertyInData,\n  noPropertyInData,\n} from \"../code\"\nimport {_, str, nil, not, Name, Code} from \"../../compile/codegen\"\nimport {checkStrictMode} from \"../../compile/util\"\n\nexport type RequiredError = ErrorObject<\n  \"required\",\n  {missingProperty: string},\n  string[] | {$data: string}\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {missingProperty}}) => str`must have required property '${missingProperty}'`,\n  params: ({params: {missingProperty}}) => _`{missingProperty: ${missingProperty}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"required\",\n  type: \"object\",\n  schemaType: \"array\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, schemaCode, data, $data, it} = cxt\n    const {opts} = it\n    if (!$data && schema.length === 0) return\n    const useLoop = schema.length >= opts.loopRequired\n    if (it.allErrors) allErrorsMode()\n    else exitOnErrorMode()\n\n    if (opts.strictRequired) {\n      const props = cxt.parentSchema.properties\n      const {definedProperties} = cxt.it\n      for (const requiredKey of schema) {\n        if (props?.[requiredKey] === undefined && !definedProperties.has(requiredKey)) {\n          const schemaPath = it.schemaEnv.baseId + it.errSchemaPath\n          const msg = `required property \"${requiredKey}\" is not defined at \"${schemaPath}\" (strictRequired)`\n          checkStrictMode(it, msg, it.opts.strictRequired)\n        }\n      }\n    }\n\n    function allErrorsMode(): void {\n      if (useLoop || $data) {\n        cxt.block$data(nil, loopAllRequired)\n      } else {\n        for (const prop of schema) {\n          checkReportMissingProp(cxt, prop)\n        }\n      }\n    }\n\n    function exitOnErrorMode(): void {\n      const missing = gen.let(\"missing\")\n      if (useLoop || $data) {\n        const valid = gen.let(\"valid\", true)\n        cxt.block$data(valid, () => loopUntilMissing(missing, valid))\n        cxt.ok(valid)\n      } else {\n        gen.if(checkMissingProp(cxt, schema, missing))\n        reportMissingProp(cxt, missing)\n        gen.else()\n      }\n    }\n\n    function loopAllRequired(): void {\n      gen.forOf(\"prop\", schemaCode as Code, (prop) => {\n        cxt.setParams({missingProperty: prop})\n        gen.if(noPropertyInData(gen, data, prop, opts.ownProperties), () => cxt.error())\n      })\n    }\n\n    function loopUntilMissing(missing: Name, valid: Name): void {\n      cxt.setParams({missingProperty: missing})\n      gen.forOf(\n        missing,\n        schemaCode as Code,\n        () => {\n          gen.assign(valid, propertyInData(gen, data, missing, opts.ownProperties))\n          gen.if(not(valid), () => {\n            cxt.error()\n            gen.break()\n          })\n        },\n        nil\n      )\n    }\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {checkDataTypes, getSchemaTypes, DataType} from \"../../compile/validate/dataType\"\nimport {_, str, Name} from \"../../compile/codegen\"\nimport {useFunc} from \"../../compile/util\"\nimport equal from \"../../runtime/equal\"\n\nexport type UniqueItemsError = ErrorObject<\n  \"uniqueItems\",\n  {i: number; j: number},\n  boolean | {$data: string}\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {i, j}}) =>\n    str`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,\n  params: ({params: {i, j}}) => _`{i: ${i}, j: ${j}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"uniqueItems\",\n  type: \"array\",\n  schemaType: \"boolean\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, $data, schema, parentSchema, schemaCode, it} = cxt\n    if (!$data && !schema) return\n    const valid = gen.let(\"valid\")\n    const itemTypes = parentSchema.items ? getSchemaTypes(parentSchema.items) : []\n    cxt.block$data(valid, validateUniqueItems, _`${schemaCode} === false`)\n    cxt.ok(valid)\n\n    function validateUniqueItems(): void {\n      const i = gen.let(\"i\", _`${data}.length`)\n      const j = gen.let(\"j\")\n      cxt.setParams({i, j})\n      gen.assign(valid, true)\n      gen.if(_`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j))\n    }\n\n    function canOptimize(): boolean {\n      return itemTypes.length > 0 && !itemTypes.some((t) => t === \"object\" || t === \"array\")\n    }\n\n    function loopN(i: Name, j: Name): void {\n      const item = gen.name(\"item\")\n      const wrongType = checkDataTypes(itemTypes, item, it.opts.strictNumbers, DataType.Wrong)\n      const indices = gen.const(\"indices\", _`{}`)\n      gen.for(_`;${i}--;`, () => {\n        gen.let(item, _`${data}[${i}]`)\n        gen.if(wrongType, _`continue`)\n        if (itemTypes.length > 1) gen.if(_`typeof ${item} == \"string\"`, _`${item} += \"_\"`)\n        gen\n          .if(_`typeof ${indices}[${item}] == \"number\"`, () => {\n            gen.assign(j, _`${indices}[${item}]`)\n            cxt.error()\n            gen.assign(valid, false).break()\n          })\n          .code(_`${indices}[${item}] = ${i}`)\n      })\n    }\n\n    function loopN2(i: Name, j: Name): void {\n      const eql = useFunc(gen, equal)\n      const outer = gen.name(\"outer\")\n      gen.label(outer).for(_`;${i}--;`, () =>\n        gen.for(_`${j} = ${i}; ${j}--;`, () =>\n          gen.if(_`${eql}(${data}[${i}], ${data}[${j}])`, () => {\n            cxt.error()\n            gen.assign(valid, false).break(outer)\n          })\n        )\n      )\n    }\n  },\n}\n\nexport default def\n","'use strict';\n\n// do not edit .js files directly - edit src/index.jst\n\n\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n","'use strict';\n\nvar traverse = module.exports = function (schema, opts, cb) {\n  // Legacy support for v0.3.1 and earlier.\n  if (typeof opts == 'function') {\n    cb = opts;\n    opts = {};\n  }\n\n  cb = opts.cb || cb;\n  var pre = (typeof cb == 'function') ? cb : cb.pre || function() {};\n  var post = cb.post || function() {};\n\n  _traverse(opts, pre, post, schema, '', schema);\n};\n\n\ntraverse.keywords = {\n  additionalItems: true,\n  items: true,\n  contains: true,\n  additionalProperties: true,\n  propertyNames: true,\n  not: true,\n  if: true,\n  then: true,\n  else: true\n};\n\ntraverse.arrayKeywords = {\n  items: true,\n  allOf: true,\n  anyOf: true,\n  oneOf: true\n};\n\ntraverse.propsKeywords = {\n  $defs: true,\n  definitions: true,\n  properties: true,\n  patternProperties: true,\n  dependencies: true\n};\n\ntraverse.skipKeywords = {\n  default: true,\n  enum: true,\n  const: true,\n  required: true,\n  maximum: true,\n  minimum: true,\n  exclusiveMaximum: true,\n  exclusiveMinimum: true,\n  multipleOf: true,\n  maxLength: true,\n  minLength: true,\n  pattern: true,\n  format: true,\n  maxItems: true,\n  minItems: true,\n  uniqueItems: true,\n  maxProperties: true,\n  minProperties: true\n};\n\n\nfunction _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {\n  if (schema && typeof schema == 'object' && !Array.isArray(schema)) {\n    pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);\n    for (var key in schema) {\n      var sch = schema[key];\n      if (Array.isArray(sch)) {\n        if (key in traverse.arrayKeywords) {\n          for (var i=0; i<sch.length; i++)\n            _traverse(opts, pre, post, sch[i], jsonPtr + '/' + key + '/' + i, rootSchema, jsonPtr, key, schema, i);\n        }\n      } else if (key in traverse.propsKeywords) {\n        if (sch && typeof sch == 'object') {\n          for (var prop in sch)\n            _traverse(opts, pre, post, sch[prop], jsonPtr + '/' + key + '/' + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);\n        }\n      } else if (key in traverse.keywords || (opts.allKeys && !(key in traverse.skipKeywords))) {\n        _traverse(opts, pre, post, sch, jsonPtr + '/' + key, rootSchema, jsonPtr, key, schema);\n      }\n    }\n    post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);\n  }\n}\n\n\nfunction escapeJsonPtr(str) {\n  return str.replace(/~/g, '~0').replace(/\\//g, '~1');\n}\n","'use strict'\n\nconst { normalizeIPv6, normalizeIPv4, removeDotSegments, recomposeAuthority, normalizeComponentEncoding } = require('./lib/utils')\nconst SCHEMES = require('./lib/schemes')\n\nfunction normalize (uri, options) {\n  if (typeof uri === 'string') {\n    uri = serialize(parse(uri, options), options)\n  } else if (typeof uri === 'object') {\n    uri = parse(serialize(uri, options), options)\n  }\n  return uri\n}\n\nfunction resolve (baseURI, relativeURI, options) {\n  const schemelessOptions = Object.assign({ scheme: 'null' }, options)\n  const resolved = resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true)\n  return serialize(resolved, { ...schemelessOptions, skipEscape: true })\n}\n\nfunction resolveComponents (base, relative, options, skipNormalization) {\n  const target = {}\n  if (!skipNormalization) {\n    base = parse(serialize(base, options), options) // normalize base components\n    relative = parse(serialize(relative, options), options) // normalize relative components\n  }\n  options = options || {}\n\n  if (!options.tolerant && relative.scheme) {\n    target.scheme = relative.scheme\n    // target.authority = relative.authority;\n    target.userinfo = relative.userinfo\n    target.host = relative.host\n    target.port = relative.port\n    target.path = removeDotSegments(relative.path || '')\n    target.query = relative.query\n  } else {\n    if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {\n      // target.authority = relative.authority;\n      target.userinfo = relative.userinfo\n      target.host = relative.host\n      target.port = relative.port\n      target.path = removeDotSegments(relative.path || '')\n      target.query = relative.query\n    } else {\n      if (!relative.path) {\n        target.path = base.path\n        if (relative.query !== undefined) {\n          target.query = relative.query\n        } else {\n          target.query = base.query\n        }\n      } else {\n        if (relative.path.charAt(0) === '/') {\n          target.path = removeDotSegments(relative.path)\n        } else {\n          if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {\n            target.path = '/' + relative.path\n          } else if (!base.path) {\n            target.path = relative.path\n          } else {\n            target.path = base.path.slice(0, base.path.lastIndexOf('/') + 1) + relative.path\n          }\n          target.path = removeDotSegments(target.path)\n        }\n        target.query = relative.query\n      }\n      // target.authority = base.authority;\n      target.userinfo = base.userinfo\n      target.host = base.host\n      target.port = base.port\n    }\n    target.scheme = base.scheme\n  }\n\n  target.fragment = relative.fragment\n\n  return target\n}\n\nfunction equal (uriA, uriB, options) {\n  if (typeof uriA === 'string') {\n    uriA = unescape(uriA)\n    uriA = serialize(normalizeComponentEncoding(parse(uriA, options), true), { ...options, skipEscape: true })\n  } else if (typeof uriA === 'object') {\n    uriA = serialize(normalizeComponentEncoding(uriA, true), { ...options, skipEscape: true })\n  }\n\n  if (typeof uriB === 'string') {\n    uriB = unescape(uriB)\n    uriB = serialize(normalizeComponentEncoding(parse(uriB, options), true), { ...options, skipEscape: true })\n  } else if (typeof uriB === 'object') {\n    uriB = serialize(normalizeComponentEncoding(uriB, true), { ...options, skipEscape: true })\n  }\n\n  return uriA.toLowerCase() === uriB.toLowerCase()\n}\n\nfunction serialize (cmpts, opts) {\n  const components = {\n    host: cmpts.host,\n    scheme: cmpts.scheme,\n    userinfo: cmpts.userinfo,\n    port: cmpts.port,\n    path: cmpts.path,\n    query: cmpts.query,\n    nid: cmpts.nid,\n    nss: cmpts.nss,\n    uuid: cmpts.uuid,\n    fragment: cmpts.fragment,\n    reference: cmpts.reference,\n    resourceName: cmpts.resourceName,\n    secure: cmpts.secure,\n    error: ''\n  }\n  const options = Object.assign({}, opts)\n  const uriTokens = []\n\n  // find scheme handler\n  const schemeHandler = SCHEMES[(options.scheme || components.scheme || '').toLowerCase()]\n\n  // perform scheme specific serialization\n  if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options)\n\n  if (components.path !== undefined) {\n    if (!options.skipEscape) {\n      components.path = escape(components.path)\n\n      if (components.scheme !== undefined) {\n        components.path = components.path.split('%3A').join(':')\n      }\n    } else {\n      components.path = unescape(components.path)\n    }\n  }\n\n  if (options.reference !== 'suffix' && components.scheme) {\n    uriTokens.push(components.scheme, ':')\n  }\n\n  const authority = recomposeAuthority(components, options)\n  if (authority !== undefined) {\n    if (options.reference !== 'suffix') {\n      uriTokens.push('//')\n    }\n\n    uriTokens.push(authority)\n\n    if (components.path && components.path.charAt(0) !== '/') {\n      uriTokens.push('/')\n    }\n  }\n  if (components.path !== undefined) {\n    let s = components.path\n\n    if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {\n      s = removeDotSegments(s)\n    }\n\n    if (authority === undefined) {\n      s = s.replace(/^\\/\\//u, '/%2F') // don't allow the path to start with \"//\"\n    }\n\n    uriTokens.push(s)\n  }\n\n  if (components.query !== undefined) {\n    uriTokens.push('?', components.query)\n  }\n\n  if (components.fragment !== undefined) {\n    uriTokens.push('#', components.fragment)\n  }\n  return uriTokens.join('')\n}\n\nconst hexLookUp = Array.from({ length: 127 }, (v, k) => /[^!\"$&'()*+,\\-.;=_`a-z{}~]/u.test(String.fromCharCode(k)))\n\nfunction nonSimpleDomain (value) {\n  let code = 0\n  for (let i = 0, len = value.length; i < len; ++i) {\n    code = value.charCodeAt(i)\n    if (code > 126 || hexLookUp[code]) {\n      return true\n    }\n  }\n  return false\n}\n\nconst URI_PARSE = /^(?:([^#/:?]+):)?(?:\\/\\/((?:([^#/?@]*)@)?(\\[[^#/?\\]]+\\]|[^#/:?]*)(?::(\\d*))?))?([^#?]*)(?:\\?([^#]*))?(?:#((?:.|[\\n\\r])*))?/u\n\nfunction parse (uri, opts) {\n  const options = Object.assign({}, opts)\n  const parsed = {\n    scheme: undefined,\n    userinfo: undefined,\n    host: '',\n    port: undefined,\n    path: '',\n    query: undefined,\n    fragment: undefined\n  }\n  const gotEncoding = uri.indexOf('%') !== -1\n  let isIP = false\n  if (options.reference === 'suffix') uri = (options.scheme ? options.scheme + ':' : '') + '//' + uri\n\n  const matches = uri.match(URI_PARSE)\n\n  if (matches) {\n    // store each component\n    parsed.scheme = matches[1]\n    parsed.userinfo = matches[3]\n    parsed.host = matches[4]\n    parsed.port = parseInt(matches[5], 10)\n    parsed.path = matches[6] || ''\n    parsed.query = matches[7]\n    parsed.fragment = matches[8]\n\n    // fix port number\n    if (isNaN(parsed.port)) {\n      parsed.port = matches[5]\n    }\n    if (parsed.host) {\n      const ipv4result = normalizeIPv4(parsed.host)\n      if (ipv4result.isIPV4 === false) {\n        const ipv6result = normalizeIPv6(ipv4result.host, { isIPV4: false })\n        parsed.host = ipv6result.host.toLowerCase()\n        isIP = ipv6result.isIPV6\n      } else {\n        parsed.host = ipv4result.host\n        isIP = true\n      }\n    }\n    if (parsed.scheme === undefined && parsed.userinfo === undefined && parsed.host === undefined && parsed.port === undefined && !parsed.path && parsed.query === undefined) {\n      parsed.reference = 'same-document'\n    } else if (parsed.scheme === undefined) {\n      parsed.reference = 'relative'\n    } else if (parsed.fragment === undefined) {\n      parsed.reference = 'absolute'\n    } else {\n      parsed.reference = 'uri'\n    }\n\n    // check for reference errors\n    if (options.reference && options.reference !== 'suffix' && options.reference !== parsed.reference) {\n      parsed.error = parsed.error || 'URI is not a ' + options.reference + ' reference.'\n    }\n\n    // find scheme handler\n    const schemeHandler = SCHEMES[(options.scheme || parsed.scheme || '').toLowerCase()]\n\n    // check if scheme can't handle IRIs\n    if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {\n      // if host component is a domain name\n      if (parsed.host && (options.domainHost || (schemeHandler && schemeHandler.domainHost)) && isIP === false && nonSimpleDomain(parsed.host)) {\n        // convert Unicode IDN -> ASCII IDN\n        try {\n          parsed.host = URL.domainToASCII(parsed.host.toLowerCase())\n        } catch (e) {\n          parsed.error = parsed.error || \"Host's domain name can not be converted to ASCII: \" + e\n        }\n      }\n      // convert IRI -> URI\n    }\n\n    if (!schemeHandler || (schemeHandler && !schemeHandler.skipNormalize)) {\n      if (gotEncoding && parsed.scheme !== undefined) {\n        parsed.scheme = unescape(parsed.scheme)\n      }\n      if (gotEncoding && parsed.host !== undefined) {\n        parsed.host = unescape(parsed.host)\n      }\n      if (parsed.path !== undefined && parsed.path.length) {\n        parsed.path = escape(unescape(parsed.path))\n      }\n      if (parsed.fragment !== undefined && parsed.fragment.length) {\n        parsed.fragment = encodeURI(decodeURIComponent(parsed.fragment))\n      }\n    }\n\n    // perform scheme specific parsing\n    if (schemeHandler && schemeHandler.parse) {\n      schemeHandler.parse(parsed, options)\n    }\n  } else {\n    parsed.error = parsed.error || 'URI can not be parsed.'\n  }\n  return parsed\n}\n\nconst fastUri = {\n  SCHEMES,\n  normalize,\n  resolve,\n  resolveComponents,\n  equal,\n  serialize,\n  parse\n}\n\nmodule.exports = fastUri\nmodule.exports.default = fastUri\nmodule.exports.fastUri = fastUri\n","'use strict'\n\nconst UUID_REG = /^[\\da-f]{8}\\b-[\\da-f]{4}\\b-[\\da-f]{4}\\b-[\\da-f]{4}\\b-[\\da-f]{12}$/iu\nconst URN_REG = /([\\da-z][\\d\\-a-z]{0,31}):((?:[\\w!$'()*+,\\-.:;=@]|%[\\da-f]{2})+)/iu\n\nfunction isSecure (wsComponents) {\n  return typeof wsComponents.secure === 'boolean' ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === 'wss'\n}\n\nfunction httpParse (components) {\n  if (!components.host) {\n    components.error = components.error || 'HTTP URIs must have a host.'\n  }\n\n  return components\n}\n\nfunction httpSerialize (components) {\n  const secure = String(components.scheme).toLowerCase() === 'https'\n\n  // normalize the default port\n  if (components.port === (secure ? 443 : 80) || components.port === '') {\n    components.port = undefined\n  }\n\n  // normalize the empty path\n  if (!components.path) {\n    components.path = '/'\n  }\n\n  // NOTE: We do not parse query strings for HTTP URIs\n  // as WWW Form Url Encoded query strings are part of the HTML4+ spec,\n  // and not the HTTP spec.\n\n  return components\n}\n\nfunction wsParse (wsComponents) {\n// indicate if the secure flag is set\n  wsComponents.secure = isSecure(wsComponents)\n\n  // construct resouce name\n  wsComponents.resourceName = (wsComponents.path || '/') + (wsComponents.query ? '?' + wsComponents.query : '')\n  wsComponents.path = undefined\n  wsComponents.query = undefined\n\n  return wsComponents\n}\n\nfunction wsSerialize (wsComponents) {\n// normalize the default port\n  if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === '') {\n    wsComponents.port = undefined\n  }\n\n  // ensure scheme matches secure flag\n  if (typeof wsComponents.secure === 'boolean') {\n    wsComponents.scheme = (wsComponents.secure ? 'wss' : 'ws')\n    wsComponents.secure = undefined\n  }\n\n  // reconstruct path from resource name\n  if (wsComponents.resourceName) {\n    const [path, query] = wsComponents.resourceName.split('?')\n    wsComponents.path = (path && path !== '/' ? path : undefined)\n    wsComponents.query = query\n    wsComponents.resourceName = undefined\n  }\n\n  // forbid fragment component\n  wsComponents.fragment = undefined\n\n  return wsComponents\n}\n\nfunction urnParse (urnComponents, options) {\n  if (!urnComponents.path) {\n    urnComponents.error = 'URN can not be parsed'\n    return urnComponents\n  }\n  const matches = urnComponents.path.match(URN_REG)\n  if (matches) {\n    const scheme = options.scheme || urnComponents.scheme || 'urn'\n    urnComponents.nid = matches[1].toLowerCase()\n    urnComponents.nss = matches[2]\n    const urnScheme = `${scheme}:${options.nid || urnComponents.nid}`\n    const schemeHandler = SCHEMES[urnScheme]\n    urnComponents.path = undefined\n\n    if (schemeHandler) {\n      urnComponents = schemeHandler.parse(urnComponents, options)\n    }\n  } else {\n    urnComponents.error = urnComponents.error || 'URN can not be parsed.'\n  }\n\n  return urnComponents\n}\n\nfunction urnSerialize (urnComponents, options) {\n  const scheme = options.scheme || urnComponents.scheme || 'urn'\n  const nid = urnComponents.nid.toLowerCase()\n  const urnScheme = `${scheme}:${options.nid || nid}`\n  const schemeHandler = SCHEMES[urnScheme]\n\n  if (schemeHandler) {\n    urnComponents = schemeHandler.serialize(urnComponents, options)\n  }\n\n  const uriComponents = urnComponents\n  const nss = urnComponents.nss\n  uriComponents.path = `${nid || options.nid}:${nss}`\n\n  options.skipEscape = true\n  return uriComponents\n}\n\nfunction urnuuidParse (urnComponents, options) {\n  const uuidComponents = urnComponents\n  uuidComponents.uuid = uuidComponents.nss\n  uuidComponents.nss = undefined\n\n  if (!options.tolerant && (!uuidComponents.uuid || !UUID_REG.test(uuidComponents.uuid))) {\n    uuidComponents.error = uuidComponents.error || 'UUID is not valid.'\n  }\n\n  return uuidComponents\n}\n\nfunction urnuuidSerialize (uuidComponents) {\n  const urnComponents = uuidComponents\n  // normalize UUID\n  urnComponents.nss = (uuidComponents.uuid || '').toLowerCase()\n  return urnComponents\n}\n\nconst http = {\n  scheme: 'http',\n  domainHost: true,\n  parse: httpParse,\n  serialize: httpSerialize\n}\n\nconst https = {\n  scheme: 'https',\n  domainHost: http.domainHost,\n  parse: httpParse,\n  serialize: httpSerialize\n}\n\nconst ws = {\n  scheme: 'ws',\n  domainHost: true,\n  parse: wsParse,\n  serialize: wsSerialize\n}\n\nconst wss = {\n  scheme: 'wss',\n  domainHost: ws.domainHost,\n  parse: ws.parse,\n  serialize: ws.serialize\n}\n\nconst urn = {\n  scheme: 'urn',\n  parse: urnParse,\n  serialize: urnSerialize,\n  skipNormalize: true\n}\n\nconst urnuuid = {\n  scheme: 'urn:uuid',\n  parse: urnuuidParse,\n  serialize: urnuuidSerialize,\n  skipNormalize: true\n}\n\nconst SCHEMES = {\n  http,\n  https,\n  ws,\n  wss,\n  urn,\n  'urn:uuid': urnuuid\n}\n\nmodule.exports = SCHEMES\n","'use strict'\n\nconst HEX = {\n  0: 0,\n  1: 1,\n  2: 2,\n  3: 3,\n  4: 4,\n  5: 5,\n  6: 6,\n  7: 7,\n  8: 8,\n  9: 9,\n  a: 10,\n  A: 10,\n  b: 11,\n  B: 11,\n  c: 12,\n  C: 12,\n  d: 13,\n  D: 13,\n  e: 14,\n  E: 14,\n  f: 15,\n  F: 15\n}\n\nmodule.exports = {\n  HEX\n}\n","'use strict'\n\nconst { HEX } = require('./scopedChars')\n\nfunction normalizeIPv4 (host) {\n  if (findToken(host, '.') < 3) { return { host, isIPV4: false } }\n  const matches = host.match(/^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/u) || []\n  const [address] = matches\n  if (address) {\n    return { host: stripLeadingZeros(address, '.'), isIPV4: true }\n  } else {\n    return { host, isIPV4: false }\n  }\n}\n\n/**\n * @param {string[]} input\n * @param {boolean} [keepZero=false]\n * @returns {string|undefined}\n */\nfunction stringArrayToHexStripped (input, keepZero = false) {\n  let acc = ''\n  let strip = true\n  for (const c of input) {\n    if (HEX[c] === undefined) return undefined\n    if (c !== '0' && strip === true) strip = false\n    if (!strip) acc += c\n  }\n  if (keepZero && acc.length === 0) acc = '0'\n  return acc\n}\n\nfunction getIPV6 (input) {\n  let tokenCount = 0\n  const output = { error: false, address: '', zone: '' }\n  const address = []\n  const buffer = []\n  let isZone = false\n  let endipv6Encountered = false\n  let endIpv6 = false\n\n  function consume () {\n    if (buffer.length) {\n      if (isZone === false) {\n        const hex = stringArrayToHexStripped(buffer)\n        if (hex !== undefined) {\n          address.push(hex)\n        } else {\n          output.error = true\n          return false\n        }\n      }\n      buffer.length = 0\n    }\n    return true\n  }\n\n  for (let i = 0; i < input.length; i++) {\n    const cursor = input[i]\n    if (cursor === '[' || cursor === ']') { continue }\n    if (cursor === ':') {\n      if (endipv6Encountered === true) {\n        endIpv6 = true\n      }\n      if (!consume()) { break }\n      tokenCount++\n      address.push(':')\n      if (tokenCount > 7) {\n        // not valid\n        output.error = true\n        break\n      }\n      if (i - 1 >= 0 && input[i - 1] === ':') {\n        endipv6Encountered = true\n      }\n      continue\n    } else if (cursor === '%') {\n      if (!consume()) { break }\n      // switch to zone detection\n      isZone = true\n    } else {\n      buffer.push(cursor)\n      continue\n    }\n  }\n  if (buffer.length) {\n    if (isZone) {\n      output.zone = buffer.join('')\n    } else if (endIpv6) {\n      address.push(buffer.join(''))\n    } else {\n      address.push(stringArrayToHexStripped(buffer))\n    }\n  }\n  output.address = address.join('')\n  return output\n}\n\nfunction normalizeIPv6 (host, opts = {}) {\n  if (findToken(host, ':') < 2) { return { host, isIPV6: false } }\n  const ipv6 = getIPV6(host)\n\n  if (!ipv6.error) {\n    let newHost = ipv6.address\n    let escapedHost = ipv6.address\n    if (ipv6.zone) {\n      newHost += '%' + ipv6.zone\n      escapedHost += '%25' + ipv6.zone\n    }\n    return { host: newHost, escapedHost, isIPV6: true }\n  } else {\n    return { host, isIPV6: false }\n  }\n}\n\nfunction stripLeadingZeros (str, token) {\n  let out = ''\n  let skip = true\n  const l = str.length\n  for (let i = 0; i < l; i++) {\n    const c = str[i]\n    if (c === '0' && skip) {\n      if ((i + 1 <= l && str[i + 1] === token) || i + 1 === l) {\n        out += c\n        skip = false\n      }\n    } else {\n      if (c === token) {\n        skip = true\n      } else {\n        skip = false\n      }\n      out += c\n    }\n  }\n  return out\n}\n\nfunction findToken (str, token) {\n  let ind = 0\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === token) ind++\n  }\n  return ind\n}\n\nconst RDS1 = /^\\.\\.?\\//u\nconst RDS2 = /^\\/\\.(?:\\/|$)/u\nconst RDS3 = /^\\/\\.\\.(?:\\/|$)/u\nconst RDS5 = /^\\/?(?:.|\\n)*?(?=\\/|$)/u\n\nfunction removeDotSegments (input) {\n  const output = []\n\n  while (input.length) {\n    if (input.match(RDS1)) {\n      input = input.replace(RDS1, '')\n    } else if (input.match(RDS2)) {\n      input = input.replace(RDS2, '/')\n    } else if (input.match(RDS3)) {\n      input = input.replace(RDS3, '/')\n      output.pop()\n    } else if (input === '.' || input === '..') {\n      input = ''\n    } else {\n      const im = input.match(RDS5)\n      if (im) {\n        const s = im[0]\n        input = input.slice(s.length)\n        output.push(s)\n      } else {\n        throw new Error('Unexpected dot segment condition')\n      }\n    }\n  }\n  return output.join('')\n}\n\nfunction normalizeComponentEncoding (components, esc) {\n  const func = esc !== true ? escape : unescape\n  if (components.scheme !== undefined) {\n    components.scheme = func(components.scheme)\n  }\n  if (components.userinfo !== undefined) {\n    components.userinfo = func(components.userinfo)\n  }\n  if (components.host !== undefined) {\n    components.host = func(components.host)\n  }\n  if (components.path !== undefined) {\n    components.path = func(components.path)\n  }\n  if (components.query !== undefined) {\n    components.query = func(components.query)\n  }\n  if (components.fragment !== undefined) {\n    components.fragment = func(components.fragment)\n  }\n  return components\n}\n\nfunction recomposeAuthority (components, options) {\n  const uriTokens = []\n\n  if (components.userinfo !== undefined) {\n    uriTokens.push(components.userinfo)\n    uriTokens.push('@')\n  }\n\n  if (components.host !== undefined) {\n    let host = unescape(components.host)\n    const ipV4res = normalizeIPv4(host)\n\n    if (ipV4res.isIPV4) {\n      host = ipV4res.host\n    } else {\n      const ipV6res = normalizeIPv6(ipV4res.host, { isIPV4: false })\n      if (ipV6res.isIPV6 === true) {\n        host = `[${ipV6res.escapedHost}]`\n      } else {\n        host = components.host\n      }\n    }\n    uriTokens.push(host)\n  }\n\n  if (typeof components.port === 'number' || typeof components.port === 'string') {\n    uriTokens.push(':')\n    uriTokens.push(String(components.port))\n  }\n\n  return uriTokens.length ? uriTokens.join('') : undefined\n};\n\nmodule.exports = {\n  recomposeAuthority,\n  normalizeComponentEncoding,\n  removeDotSegments,\n  normalizeIPv4,\n  normalizeIPv6,\n  stringArrayToHexStripped\n}\n"],"names":["core_1","require","draft7_1","discriminator_1","draft7MetaSchema","META_SUPPORT_DATA","META_SCHEMA_ID","Ajv","default","_addVocabularies","super","forEach","v","this","addVocabulary","opts","discriminator","addKeyword","_addDefaultMetaSchema","meta","metaSchema","$data","$dataMetaSchema","addMetaSchema","refs","defaultMeta","getSchema","undefined","exports","module","Object","defineProperty","value","validate_1","enumerable","get","KeywordCxt","codegen_1","_","str","stringify","nil","Name","CodeGen","validation_error_1","ref_error_1","_CodeOrName","constructor","s","IDENTIFIER","test","Error","toString","emptyStr","names","_Code","code","_items","length","item","_a","_str","reduce","c","_names","strs","i","_len","arguments","args","Array","_key","addCodeArg","push","plus","expr","safeStringify","_len2","_key2","res","mergeExprItems","splice","optimize","arg","x","isArray","join","a","b","slice","JSON","replace","c1","c2","key","rx","code_1","scope_1","code_2","strConcat","getProperty","regexpCode","scope_2","Scope","ValueScope","ValueScopeName","varKinds","GT","GTE","LT","LTE","EQ","NEQ","NOT","OR","AND","ADD","Node","optimizeNodes","optimizeNames","_constants","Def","varKind","name","rhs","render","_ref","es5","_n","var","constants","optimizeExpr","Assign","lhs","sideEffects","_ref2","addExprNames","AssignOp","op","_ref3","Label","label","_ref4","Break","_ref5","Throw","error","_ref6","AnyCode","_ref7","ParentNode","nodes","n","subtractNames","addNames","BlockNode","Root","Else","kind","If","condition","else","cond","e","ns","not","For","ForLoop","iteration","ForRange","from","to","ForIter","loop","iterable","Func","async","Return","Try","catch","finally","_b","Catch","Finally","replaceName","some","items","par","extScope","_values","_blockStarts","lines","_extScope","_scope","parent","_nodes","_root","prefix","scopeName","scopeValue","prefixOrName","Set","add","getScopeValue","keyOrRef","getValue","scopeRefs","scopeCode","_def","nameOrPrefix","constant","toName","_leafNode","const","_constant","let","assign","operators","object","keyValues","if","thenBody","elseBody","_blockNode","endIf","elseIf","_elseNode","_endBlockNode","_for","node","forBody","endFor","for","forRange","forOf","arr","forIn","obj","ownProperties","break","return","try","tryBody","catchCode","finallyCode","_currNode","throw","block","body","nodeCount","endBlock","len","pop","toClose","func","funcBody","endFunc","N1","N2","andCode","mappend","orCode","y","_len3","_key3","ValueError","UsedValueState","prefixes","_prefixes","_parent","_newName","_nameGroup","index","has","nameStr","setValue","property","itemIndex","scopePath","line","scope","ref","valueKey","vs","_name","Map","set","values","_reduceValues","usedValues","getCode","valueCode","nameSet","Started","def","Completed","util_1","names_1","addError","gen","errObj","err","vErrors","errors","returnErrors","it","errs","validateName","schemaEnv","$async","ValidationError","message","keyword","schemaType","cxt","keywordError","errorPaths","overrideAllErrors","compositeRule","allErrors","errorObjectCode","errsCount","schemaValue","data","instancePath","errorPath","errSchemaPath","verbose","E","schemaPath","params","propertyName","schema","parentSchema","createErrors","errorInstancePath","errorSchemaPath","_ref8","topSchemaRef","messages","extraErrorProps","errorObject","instPath","getErrorPath","Type","Str","schPath","resolve_1","SchemaEnv","env","dynamicAnchors","schemaId","root","baseId","normalizeId","localRefs","compileSchema","sch","_sch","getCompilingSchema","call","rootId","getFullPath","uriResolver","_ValidationError","schemaCxt","parentData","parentDataProperty","dataNames","dataPathArr","dataLevel","dataTypes","definedProperties","source","jtd","self","sourceCode","_compilations","validateFunctionCode","validateCode","process","validate","Function","makeValidate","scopeValues","unevaluated","props","evaluated","dynamicProps","dynamicItems","logger","delete","inlineOrCompile","inlineRef","inlineRefs","schEnv","s2","s1","resolve","schemas","resolveSchema","p","parse","refPath","_getFullPath","keys","getJsonPointer","id","schOrRef","schId","resolveUrl","schOrFunc","PREVENT_SCOPE_CHANGE","parsedRef","fragment","part","split","partSchema","unescapeFragment","$ref","schemaHasRulesButRef","RULES","valCxt","rootData","json","jsonPos","jsonLen","jsonPart","MissingRefError","resolver","msg","missingRef","missingSchema","equal","traverse","SIMPLE_INLINED","limit","hasRef","countKeys","REF_KEYWORDS","count","Infinity","eachItem","serialize","TRAILING_SLASH_HASH","ANCHOR","baseIds","pathPrefix","schemaRefs","allKeys","jsonPtr","parentJsonPtr","fullPath","innerBaseId","addRef","_resolve","ambiguos","checkAmbiguosRef","addAnchor","anchor","$anchor","$dynamicAnchor","sch1","sch2","jsonTypes","groups","number","type","rules","string","array","types","integer","boolean","null","post","all","keywords","checkUnknownRules","strictSchema","checkStrictMode","schemaHasRules","escapeJsonPointer","unescapeJsonPointer","makeMergeEvaluated","mergeNames","mergeToName","mergeValues","resultToName","evaluatedPropsToName","ps","setEvaluated","hash","decodeURIComponent","encodeURIComponent","xs","f","Math","max","snippets","mode","warn","dataProp","dataPropType","jsPropertySyntax","isNumber","Num","shouldUseGroup","group","rule","shouldUseRule","definition","implements","kwd","errors_1","boolError","falseSchemaError","schemaCode","reportError","valid","rules_1","applicability_1","DataType","getJSONTypes","ts","every","isJSONType","includes","nullable","coerceTo","coerceTypes","filter","t","COERCIBLE","coerceToTypes","checkTypes","schemaHasRulesForType","wrongType","checkDataTypes","strictNumbers","Wrong","dataType","coerced","coerceSpecificType","reportTypeError","assignParentData","coerceData","checkDataType","strictNums","correct","Correct","numCond","_cond","and","toHash","notObj","typeError","schemaRefOrVal","getTypeErrorContext","assignDefault","prop","defaultValue","childData","useDefaults","ty","properties","boolSchema_1","dataType_1","dataType_2","defaults_1","keyword_1","subschema_1","validateFunction","funcSourceUrl","dynamicRef","destructureValCxtES5","destructureValCxt","subschemaCode","isSchemaObj","checkKeywords","schemaCxtHasRules","$comment","commentKeyword","updateContext","checkAsyncSchema","typeAndKeywords","subSchemaObjCode","boolOrEmptySchema","ignoreKeywordsWithRef","checkRefsAndKeywords","schemaKeywords","getSchemaTypes","coerceAndCheckDataType","rootName","typeErrors","groupKeywords","iterateKeywords","strictTypes","includesType","strictTypesError","withTypes","narrowSchemaTypes","checkContextTypes","allowUnionTypes","checkMultipleTypes","hasApplicableType","checkKeywordTypes","checkStrictTypes","keywordCode","assignDefaults","schTs","kwdT","checkNoDefault","resetEvaluated","assignEvaluated","returnResults","topSchemaObjCode","topBoolOrEmptySchema","validateKeywordUsage","getData","validSchemaType","allowUndefined","trackErrors","result","successAction","failAction","failResult","pass","fail","fail$data","or","invalid$data","append","errorParams","setParams","_error","reportExtraError","$dataError","keyword$DataError","reset","resetErrorsCount","ok","block$data","codeBlock","$dataValid","check$data","validateSchema","st","wrong$DataType","validateSchemaRef","invalid$DataSchema","subschema","appl","getSubschema","extendSubschemaData","extendSubschemaMode","nextContext","mergeEvaluated","mergeValidEvaluated","ruleType","funcKeywordCode","macroKeywordCode","compile","JSON_POINTER","RELATIVE_JSON_POINTER","jsonPointer","matches","exec","up","errorMsg","segments","segment","pointerType","modifyData","useKeyword","macroSchema","macro","schemaRef","checkAsyncKeyword","validateRef","assignValid","_await","passCxt","passContext","passSchema","callValidateCode","modifying","reportErrs","ruleErrs","validateAsync","validateErrs","validateSync","extendErrors","addErrs","deps","dependencies","prototype","hasOwnProperty","errorsText","schemaProp","escapeFragment","dpType","dataContextProps","_nextData","jtdDiscriminator","jtdMetadata","compile_1","codegen_2","$dataRefSchema","uri_1","defaultRegExp","flags","RegExp","META_IGNORE_OPTIONS","EXT_SCOPE_NAMES","removedOptions","errorDataPath","format","jsonPointers","extendRefs","missingRefs","processCode","strictDefaults","strictKeywords","uniqueItems","unknownFormats","cache","ajvErrors","deprecatedOptions","unicode","requiredOptions","o","strict","_optz","regExp","_c","_d","_f","_e","_h","_g","_k","_j","strictTuples","_m","_l","strictRequired","_p","_o","loopRequired","_q","loopEnum","_r","_s","_t","_u","_v","addUsedSchema","_w","_x","validateFormats","_y","unicodeRegExp","_z","int32range","_0","formats","_loading","_cache","noLogs","console","log","getLogger","formatOpt","getRules","checkOptions","_metaOpts","getMetaSchemaOptions","addInitialFormats","addInitialKeywords","addInitialSchemas","_dataRefSchema","$id","schemaKeyRef","_meta","_addSchema","_compileSchemaEnv","compileAsync","loadSchema","runCompileAsync","_schema","loadMetaSchema","$schema","_compileAsync","checkLoaded","loadMissingSchema","_loadSchema","addSchema","_validateSchema","_checkUnique","throwOrLogError","keyRef","getSchEnv","removeSchema","_removeAllSchemas","clear","cacheKey","definitions","kwdOrDef","checkKeyword","addRule","keywordMetaschema","k","getKeyword","removeKeyword","findIndex","addFormat","separator","dataVar","map","text","keywordsJsonPointers","seg","schemaOrData","regex","getSchemaRefs","startsWith","_compileMetaSchema","currentOpts","checkOpts","options","opt","optsSchemas","defs","metaOpts","KEYWORD_NAME","ruleGroup","find","before","addBeforeRule","_rule","$dataRef","anyOf","ucs2length","pos","charCodeAt","uri","ajv","validation","validateAdditionalItems","alwaysValidSchema","validateItems","additionalProperty","removeAdditional","allSchemaProperties","patProps","patternProperties","deleteAdditional","additionalPropertyCode","applyAdditionalSchema","definedProp","propsSchema","isOwnProperty","usePattern","isAdditional","schCxt","validateUnion","min","minContains","maxContains","next","validateItemsWithCount","schValid","checkLimits","_valid","depsCount","property_ies","missingProperty","propDeps","schDeps","propertyDeps","schemaDeps","splitDependencies","validatePropertyDeps","validateSchemaDeps","missing","hasProperty","propertyInData","depProp","checkReportMissingProp","checkMissingProp","reportMissingProp","ifClause","then","hasThen","hasSchema","hasElse","validateIf","validateClause","additionalItems_1","prefixItems_1","items_1","items2020_1","contains_1","dependencies_1","propertyNames_1","additionalProperties_1","properties_1","patternProperties_1","not_1","anyOf_1","oneOf_1","allOf_1","if_1","thenElse_1","draft2020","applicator","validateTuple","validateArray","extraItems","schArr","l","fullTuple","minItems","maxItems","checkStrictTuple","prefixItems","passing","util_2","patterns","alwaysValidPatterns","checkProperties","allowMatchingProperties","checkMatchingProperties","pat","validateProperties","alwaysValid","validatePatternProperties","additionalProperties","allProps","hasDefault","applyPropertySchema","hasPropFunc","noPropertyInData","schemaMap","context","dataAndSchema","newRegExp","pattern","u","useFunc","validArr","notValid","id_1","ref_1","core","callRef","callRootRef","schOrEnv","resolveRef","getValidate","callValidate","schName","inlineRefSchema","addErrorsFrom","addEvaluatedFrom","schEvaluated","callAsyncRef","types_1","discrError","tagName","DiscrError","Tag","tag","oneOf","mapping","applyTagSchema","oneOfMapping","topRequired","hasRequired","tagRequired","propSch","addMappings","required","addMapping","enum","tagValue","getMapping","Mapping","validateMapping","validation_1","applicator_1","format_1","metadata_1","draft7Vocabularies","metadataVocabulary","contentVocabulary","fmts","fDef","fType","callFormat","validData","invalidFmt","validate$DataFormat","formatDef","unknownMsg","unknownFormat","fmtType","fmtRef","fmtDef","fmt","getFormat","validCondition","validateFormat","equal_1","useLoop","eql","getEql","vSchema","equalCode","limitNumber_1","multipleOf_1","limitLength_1","pattern_1","limitProperties_1","required_1","limitItems_1","uniqueItems_1","const_1","enum_1","comp","ucs2length_1","ops","KWDs","maximum","okStr","minimum","exclusiveMaximum","exclusiveMinimum","prec","multipleOfPrecision","invalid","loopAllRequired","allErrorsMode","loopUntilMissing","exitOnErrorMode","requiredKey","j","itemTypes","loopN","indices","loopN2","outer","valueOf","cb","_traverse","pre","rootSchema","parentKeyword","keyIndex","arrayKeywords","propsKeywords","skipKeywords","additionalItems","contains","propertyNames","allOf","$defs","multipleOf","maxLength","minLength","maxProperties","minProperties","normalizeIPv6","normalizeIPv4","removeDotSegments","recomposeAuthority","normalizeComponentEncoding","SCHEMES","resolveComponents","base","relative","skipNormalization","target","tolerant","scheme","userinfo","host","port","path","query","charAt","lastIndexOf","cmpts","components","nid","nss","uuid","reference","resourceName","secure","uriTokens","schemeHandler","toLowerCase","skipEscape","unescape","escape","authority","absolutePath","hexLookUp","String","fromCharCode","URI_PARSE","parsed","gotEncoding","indexOf","isIP","match","parseInt","isNaN","ipv4result","isIPV4","ipv6result","isIPV6","unicodeSupport","domainHost","nonSimpleDomain","URL","domainToASCII","skipNormalize","encodeURI","fastUri","normalize","baseURI","relativeURI","schemelessOptions","uriA","uriB","UUID_REG","URN_REG","isSecure","wsComponents","httpParse","httpSerialize","http","ws","https","wss","urn","urnComponents","urnScheme","uriComponents","uuidComponents","HEX","A","B","C","d","D","F","findToken","address","stripLeadingZeros","stringArrayToHexStripped","input","keepZero","acc","strip","ipv6","tokenCount","output","zone","buffer","isZone","endipv6Encountered","endIpv6","consume","hex","cursor","getIPV6","newHost","escapedHost","token","out","skip","ind","RDS1","RDS2","RDS3","RDS5","ipV4res","ipV6res","esc","im"],"sourceRoot":""}